<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>平时积累</title>
      <link href="/posts/730b8fb7.html"/>
      <url>/posts/730b8fb7.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、重装系统"><a href="#1、重装系统" class="headerlink" title="1、重装系统"></a>1、重装系统</h1><h2 id="1-1、备份环境变量的注册表"><a href="#1-1、备份环境变量的注册表" class="headerlink" title="1.1、备份环境变量的注册表"></a>1.1、备份环境变量的注册表</h2><blockquote><p>​备份环境变量的目的是让你操作系统之后不需要再去配置环境变量</p></blockquote><p>​<code>Win+R</code>输入<code>regedit</code></p><p>​打开下面这个地址</p><p>​<strong>系统环境变量</strong>位置</p><p>​<code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment</code></p><p>​<strong>用户环境变量</strong>位置</p><p>​<code>HKEY_CURRENT_USER\Environment</code></p><p>​分别<code>用户环境变量</code>和<code>系统环境变量</code>在<code>Environment</code>上右击点击<code>导出</code>就好了</p><p>​<strong>记得备份好，不要重装完系统备份的东西没了，重装系统之后双击就行了</strong></p><p>​<strong>建议将软件都装在D盘，如果你只有一个盘当我没说</strong></p><h2 id="1-2、高级玩法"><a href="#1-2、高级玩法" class="headerlink" title="1.2、高级玩法"></a>1.2、高级玩法</h2><p>​不想写</p><h1 id="2、Windows安装"><a href="#2、Windows安装" class="headerlink" title="2、Windows安装"></a>2、Windows安装</h1><h2 id="2-1、Windows镜像地址"><a href="#2-1、Windows镜像地址" class="headerlink" title="2.1、Windows镜像地址"></a>2.1、Windows镜像地址</h2><p>​Windows10：<a href="https://www.microsoft.com/zh-cn/software-download/windows10">https://www.microsoft.com/zh-cn/software-download/windows10</a></p><p>​Windows11：<a href="https://www.microsoft.com/zh-cn/software-download/windows11">https://www.microsoft.com/zh-cn/software-download/windows11</a></p><p>​也可以通过<code>Rufus</code>下载windows镜像</p><h2 id="2-2、下载和制作USB启动盘"><a href="#2-2、下载和制作USB启动盘" class="headerlink" title="2.2、下载和制作USB启动盘"></a>2.2、下载和制作USB启动盘</h2><p>​Rufus - 轻松创建USB启动盘：<a href="http://rufus.ie/zh/">http://rufus.ie/zh/</a></p><h2 id="2-3、重启用U盘启动"><a href="#2-3、重启用U盘启动" class="headerlink" title="2.3、重启用U盘启动"></a>2.3、重启用U盘启动</h2><p>​分区直接将c盘，esp，mbr分区删除，然后直接选中未分配的区域点下一步就行了</p><h2 id="2-4、进入系统"><a href="#2-4、进入系统" class="headerlink" title="2.4、进入系统"></a>2.4、进入系统</h2><h3 id="可选操作"><a href="#可选操作" class="headerlink" title="可选操作"></a>可选操作</h3><p>​将桌面路径修改至D盘，操作过程</p><p>​<code>此电脑</code>—–&gt;<code>桌面</code>—–&gt;<code>属性</code>—–&gt;<code>位置</code>—–&gt;直接将C改为D就好了</p><p>​其它依次这样操作</p><h2 id="2-5、激活windows、office"><a href="#2-5、激活windows、office" class="headerlink" title="2.5、激活windows、office"></a>2.5、激活windows、office</h2><p>​云萌window激活、版本转换：<a href="https://cmwtat.cloudmoe.com/cn.html">https://cmwtat.cloudmoe.com/cn.html</a></p><p>​HEU_KMS_Acticator：<a href="https://github.com/zbezj/HEU_KMS_Activator">https://github.com/zbezj/HEU_KMS_Activator</a></p><p>​Office Tools <a href="https://otp.landian.vip/zh-cn/">https://otp.landian.vip/zh-cn/</a></p><h2 id="2-6、PE"><a href="#2-6、PE" class="headerlink" title="2.6、PE"></a>2.6、PE</h2><p>​<a href="https://firpe.cn/page-247">https://firpe.cn/page-247</a></p><h1 id="3、必备软件"><a href="#3、必备软件" class="headerlink" title="3、必备软件"></a>3、必备软件</h1><h2 id="3-1、装驱动"><a href="#3-1、装驱动" class="headerlink" title="3.1、装驱动"></a>3.1、装驱动</h2><p>​如果没有无线网卡，去你电脑品牌的官网下载驱动就行了，</p><h2 id="3-2、浏览器"><a href="#3-2、浏览器" class="headerlink" title="3.2、浏览器"></a>3.2、浏览器</h2><p>​Edge(自带，推荐，因为可以同步)</p><p>​Google Chrome(谷歌浏览器)： <a href="https://www.google.cn/chrome/index.html">https://www.google.cn/chrome/index.html</a></p><h2 id="3-3、Bandizip-解压软件"><a href="#3-3、Bandizip-解压软件" class="headerlink" title="3.3、Bandizip(解压软件)"></a>3.3、Bandizip(解压软件)</h2><p>​Bandizip：<a href="http://www.bandisoft.com/">http://www.bandisoft.com/</a></p><h2 id="3-4、安全软件"><a href="#3-4、安全软件" class="headerlink" title="3.4、安全软件"></a>3.4、安全软件</h2><p>​火绒安全：<a href="https://www.huorong.cn/">https://www.huorong.cn/</a></p><h2 id="3-5、截图软件"><a href="#3-5、截图软件" class="headerlink" title="3.5、截图软件"></a>3.5、截图软件</h2><p>​Snipaste：<a href="https://zh.snipaste.com/">https://zh.snipaste.com/</a></p><p>​Snipaste微软商店地址：<a href="https://www.microsoft.com/zh-cn/p/snipaste/9p1wxpkb68kx">https://www.microsoft.com/zh-cn/p/snipaste/9p1wxpkb68kx</a></p><h2 id="3-6、文本编辑软件"><a href="#3-6、文本编辑软件" class="headerlink" title="3.6、文本编辑软件"></a>3.6、文本编辑软件</h2><p>​Sublime Text：<a href="http://www.sublimetext.com/">http://www.sublimetext.com/</a></p><p>​notepad++：<a href="https://github.com/notepad-plus-plus/notepad-plus-plus/releases">https://github.com/notepad-plus-plus/notepad-plus-plus/releases</a></p><h2 id="3-7、Office破解版安装"><a href="#3-7、Office破解版安装" class="headerlink" title="3.7、Office破解版安装"></a>3.7、Office破解版安装</h2><p>​Office Tools <a href="https://otp.landian.vip/zh-cn/">https://otp.landian.vip/zh-cn/</a></p><h1 id="4、其他软件"><a href="#4、其他软件" class="headerlink" title="4、其他软件"></a>4、其他软件</h1><h2 id="4-1、jetbrains全家桶补丁"><a href="#4-1、jetbrains全家桶补丁" class="headerlink" title="4.1、jetbrains全家桶补丁"></a>4.1、jetbrains全家桶补丁</h2><p>​配合：<a href="https://jetbra.in/s">https://jetbra.in/s</a></p><p>​补丁地址：<a href="https://github.com/ja-netfilter/ja-netfilter">https://github.com/ja-netfilter/ja-netfilter</a></p><p>​知了大神： <a href="https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html">https://zhile.io/2021/11/29/ja-netfilter-javaagent-lib.html</a></p><h2 id="4-2、流氓软件删除"><a href="#4-2、流氓软件删除" class="headerlink" title="4.2、流氓软件删除"></a>4.2、流氓软件删除</h2><p>​SoftCnKiller高速下载器捆绑软件杀手：<a href="https://softcnkiller.blog.csdn.net/article/details/104799162?spm=1001.2014.3001.5502">https://softcnkiller.blog.csdn.net/article/details/104799162?spm=1001.2014.3001.5502</a></p><h2 id="4-3、idm补丁"><a href="#4-3、idm补丁" class="headerlink" title="4.3、idm补丁"></a>4.3、idm补丁</h2><p>​补丁作者：<a href="https://ckk.ir/863/%d8%af%d8%a7%d9%86%d9%84%d9%88%d8%af-%d8%a8%d9%87%d8%aa%d8%b1%db%8c%d9%86-%da%a9%d8%b1%da%a9-idm-internet-download-manager/">https://ckk.ir/863/%d8%af%d8%a7%d9%86%d9%84%d9%88%d8%af-%d8%a8%d9%87%d8%aa%d8%b1%db%8c%d9%86-%da%a9%d8%b1%da%a9-idm-internet-download-manager/</a></p><p>​放在idm根目录就好</p><h2 id="4-4、Clash（包括中文地址）"><a href="#4-4、Clash（包括中文地址）" class="headerlink" title="4.4、Clash（包括中文地址）"></a>4.4、Clash（包括中文地址）</h2><p>​Clash_for_windows_pkg：<a href="https://archive.org/details/clash_for_windows_pkg">https://archive.org/details/clash_for_windows_pkg</a></p><p>​Clash Verge <a href="https://github.com/zzzgydi/clash-verge/releases">https://github.com/zzzgydi/clash-verge/releases</a></p><p>​Clash For Windows 汉化补丁和汉化脚本：<a href="https://github.com/Z-Siqi/Clash-for-Windows_Chinese">https://github.com/Z-Siqi/Clash-for-Windows_Chinese</a><br>​<a href="https://github.com/ender-zhao/Clash-for-Windows_Chinese">https://github.com/ender-zhao/Clash-for-Windows_Chinese</a></p><p>​ClashForAndroid：<a href="https://web.archive.org/web/20231103071433/https://github.com/Kr328/ClashForAndroid">https://web.archive.org/web/20231103071433/https://github.com/Kr328/ClashForAndroid</a></p><pre><code> ClashMetaForAndroid：https://github.com/MetaCubeX/ClashMetaForAndroid</code></pre><h2 id="4-5、Burpsuite-pro"><a href="#4-5、Burpsuite-pro" class="headerlink" title="4.5、Burpsuite_pro"></a>4.5、Burpsuite_pro</h2><p>​BurpLoaderKeygen: Burp Suite Pro Loader &amp; Keygen：<a href="https://github.com/h3110w0r1d-y/BurpLoaderKeygen">https://github.com/h3110w0r1d-y/BurpLoaderKeygen</a></p><h2 id="4-6、M3U8视频下载"><a href="#4-6、M3U8视频下载" class="headerlink" title="4.6、M3U8视频下载"></a>4.6、M3U8视频下载</h2><p>​M3U8批量下载器：<a href="https://www.52pojie.cn/thread-1374045-1-1.html">https://www.52pojie.cn/thread-1374045-1-1.html</a></p><h1 id="5、网站一键安装脚本"><a href="#5、网站一键安装脚本" class="headerlink" title="5、网站一键安装脚本"></a>5、网站一键安装脚本</h1><p>​自动安装 - OneinStack：<a href="https://oneinstack.com/auto/">https://oneinstack.com/auto/</a></p><p>​LNMP一键安装包：<a href="https://lnmp.org/">https://lnmp.org/</a></p><p>​宝塔：<a href="https://www.bt.cn/">https://www.bt.cn</a></p><h1 id="6、Linux"><a href="#6、Linux" class="headerlink" title="6、Linux"></a>6、Linux</h1><p>​一键更换国内软件源 :<a href="https://github.com/SuperManito/LinuxMirrors">https://github.com/SuperManito/LinuxMirrors</a></p><h1 id="7、配置wls2-与windows主机的连通性"><a href="#7、配置wls2-与windows主机的连通性" class="headerlink" title="7、配置wls2 与windows主机的连通性"></a>7、配置wls2 与windows主机的连通性</h1><p>​powershell 管理员运行</p><pre><code class="highlight powershell"><span class="built_in">New-NetFirewallRule</span> <span class="literal">-DisplayName</span> <span class="string">&quot;WSL&quot;</span> <span class="literal">-Direction</span> Inbound  <span class="literal">-InterfaceAlias</span> <span class="string">&quot;vEthernet (WSL)&quot;</span>  <span class="literal">-Action</span> Allow</code></pre><p>​如果还不能ping通说明windows 主机拒绝了icmp报文</p><h3 id="配置防火墙规则"><a href="#配置防火墙规则" class="headerlink" title="配置防火墙规则"></a>配置防火墙规则</h3><p>​入站规则—&gt;<code>核心网络诊断-ICMP回显请求(ICMPv4-In)</code>勾选启用就行了</p><h3 id="clash-for-windows-设置"><a href="#clash-for-windows-设置" class="headerlink" title="clash for windows 设置"></a>clash for windows 设置</h3><p>​打开 Allow LAN，</p><p>​在wsl中环境变量，统计下面代码，添加到<code>.bashrc</code>这个文件最后，</p><pre><code class="highlight bash">port=25648hostip=$(<span class="built_in">cat</span> /etc/resolv.conf | grep nameserver | awk <span class="string">&#x27;&#123; print $2 &#125;&#x27;</span>)<span class="comment"># setp是设置代理的命令，可以自定义</span><span class="built_in">alias</span> setp=<span class="string">&#x27;export https_proxy=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;;export http_proxy=&quot;http://$&#123;hostip&#125;:$&#123;port&#125;&quot;;export all_proxy=&quot;socks5://$&#123;hostip&#125;:$&#123;port&#125;&quot;;export ALL_PROXY=&quot;socks5://$&#123;hostip&#125;:$&#123;port&#125;&quot;;echo &quot;set proxy:&quot;;env|grep -i proxy&#x27;</span><span class="comment"># unsetp是取消代理的命令，可以自定义</span><span class="built_in">alias</span> unsetp=<span class="string">&#x27;unset https_proxy; unset http_proxy; unset all_proxy; unset ALL_PROXY;echo &quot;clear proxy:&quot;;env|grep -i proxy&#x27;</span></code></pre><h1 id="8、小工具"><a href="#8、小工具" class="headerlink" title="8、小工具"></a>8、小工具</h1><p>查看自己代理ip</p><p><a href="http://23.80.5.90/ip.php">http://23.80.5.90/ip.php</a></p><p>查看电脑出口公网ip</p><p><a href="http://www.cip.cc/">http://www.cip.cc/</a></p><p><a href="https://tool.lu/netcard/">https://tool.lu/netcard/</a></p><h1 id="9、直播录屏软件"><a href="#9、直播录屏软件" class="headerlink" title="9、直播录屏软件"></a>9、直播录屏软件</h1><p><code>Open Broadcaster Software | OBS</code></p><pre><code class="highlight plaintext">https://obsproject.com</code></pre><h1 id="10、流氓垃圾软件清理工具"><a href="#10、流氓垃圾软件清理工具" class="headerlink" title="10、流氓垃圾软件清理工具"></a>10、流氓垃圾软件清理工具</h1><p>清理工具<code>SoftCnKiller高速下载器捆绑软件杀手</code></p><pre><code class="highlight plaintext">https://blog.csdn.net/hfhbutn/article/details/104799162</code></pre><p>免疫工具<code>小鱼儿yr系统封装优化设置辅助工具</code></p><pre><code class="highlight plaintext">https://www.yrxitong.com/h-nd-100.html</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多态</title>
      <link href="/posts/d2b9d54.html"/>
      <url>/posts/d2b9d54.html</url>
      
        <content type="html"><![CDATA[<pre><code class="highlight python"><span class="comment"># -*- Codeing = utf-8 -*-</span><span class="comment"># @Time : 2021-11-27 下午 1:43</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : object09.py</span><span class="comment"># @Software : PyCharm</span><span class="comment"># class Person:</span><span class="comment">#     def __init__(self, name):</span><span class="comment">#         self.name = name</span><span class="comment">#</span><span class="comment">#     def eat(self):</span><span class="comment">#         print(&#x27;----------&gt;eat1&#x27;)</span><span class="comment">#</span><span class="comment">#     def eat(self, food):</span><span class="comment">#         print(&#x27;-----------&gt;eat：&#x27;, food)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># p = Person(&#x27;jack&#x27;)</span><span class="comment"># p.eat(&#x27;肉丸子&#x27;)</span><span class="keyword">import</span> inspect<span class="keyword">class</span> <span class="title class_">Base</span>:    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;------base&#x27;</span>)<span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">Base</span>):    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;AAAAAAAAAA&#x27;</span>)<span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">Base</span>):    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;BBBBBBBBBB&#x27;</span>)<span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">Base</span>):    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;CCCCCCCCCC&#x27;</span>)<span class="keyword">class</span> <span class="title class_">D</span>(A, B, C):    <span class="keyword">pass</span><span class="comment"># c = C()</span><span class="comment"># c.test()</span><span class="comment"># c.test1()</span><span class="comment"># c.test2()</span>d = D()d.test()<span class="built_in">print</span>(inspect.getmro(D))<span class="built_in">print</span>(D.__mro__)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">python允许多继承</span><span class="string">def 子类（父类1，父类2）</span><span class="string">    pas</span><span class="string"></span><span class="string">如果父类有相同方法名称，搜索顺序是，</span><span class="string">自己-父类1-父类2。。。。-父类中的父类</span><span class="string"></span><span class="string"></span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight python"><span class="comment"># -*- Codeing = utf-8 -*-</span><span class="comment"># @Time : 2021-11-27 下午 2:17</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : object10.py</span><span class="comment"># @Software : PyCharm</span><span class="comment"># 多继承的搜索顺序，经典类，新式类</span><span class="keyword">class</span> <span class="title class_">P1</span>():    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;p1====foo&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;p1------bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">P2</span>():    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;p2------.foo&#x27;</span>)<span class="keyword">class</span> <span class="title class_">C1</span>(P1, P2):    <span class="keyword">pass</span><span class="keyword">class</span> <span class="title class_">C2</span>(P1, P2):    <span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;C2====bar&#x27;</span>)<span class="keyword">class</span> <span class="title class_">D1</span>(C1, C2):    <span class="keyword">pass</span>d = D1()d.foo()d.bar()<span class="built_in">print</span>(D1.__mro__)</code></pre><pre><code class="highlight python"><span class="comment"># -*- Codeing = utf-8 -*-</span><span class="comment"># @Time : 2021-11-27 下午 2:40</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : object11.py</span><span class="comment"># @Software : PyCharm</span><span class="string">&quot;&quot;&quot;</span><span class="string">私有化：</span><span class="string">    __age</span><span class="string">    def __show(self):</span><span class="string">        pass</span><span class="string">    ---&gt;__类名__属性</span><span class="string">    私有化：封装 将属性私有化，定义公有set和get方法</span><span class="string">    def setAge(self, age):</span><span class="string">        判断</span><span class="string">    def getAge(self):</span><span class="string">        return self.__age</span><span class="string"></span><span class="string">    s.setAge(20)</span><span class="string">    s.getAge()</span><span class="string"></span><span class="string">    class Studnt:</span><span class="string">        def __init__(self,age):</span><span class="string">            self.__age=age</span><span class="string"></span><span class="string">        @property</span><span class="string">        def age(self):</span><span class="string">            return ...</span><span class="string">        @age.setter</span><span class="string">        def age(self,age):</span><span class="string">            self.__age=age</span><span class="string">    s = student()</span><span class="string">    s.age = 10</span><span class="string">    print(s.age)</span><span class="string"></span><span class="string"></span><span class="string">    继承：</span><span class="string">        has a</span><span class="string">        class Student：</span><span class="string">            def __init__(self,name,book):</span><span class="string">                pass</span><span class="string"></span><span class="string">        is a    # 真正的继承</span><span class="string">            父类  子类</span><span class="string">            class Person:</span><span class="string">                pass</span><span class="string"></span><span class="string">            class Student(Person):</span><span class="string">                ...</span><span class="string">                def study(self):</span><span class="string">                    ...</span><span class="string">                def</span><span class="string">        s = Student()</span><span class="string">        s.study()</span><span class="string"></span><span class="string">        1.__init__</span><span class="string">        2.重写方法</span><span class="string"></span><span class="string">    多继承：</span><span class="string">        class A:</span><span class="string">            pass</span><span class="string">        class B:</span><span class="string">            pass</span><span class="string">        class C(A,B):</span><span class="string">            pass</span><span class="string">        python3使用新式类：广度优先</span><span class="string">        python2使用经典类：深度优先</span><span class="string"></span><span class="string">        查看搜索顺序</span><span class="string">        C.__mor__</span><span class="string">        import inspect</span><span class="string">        priny(inspect.getmro(C))</span><span class="string">&quot;&quot;&quot;</span><span class="comment"># 面向对象的特点：多态   封装  继承</span><span class="keyword">class</span> <span class="title class_">Person</span>:    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):        <span class="variable language_">self</span>.name = name    <span class="keyword">def</span> <span class="title function_">feed_pet</span>(<span class="params">self, pet</span>):    <span class="comment"># pet既可以接受cat，也可以接受dog，还可以接收tiger</span>        <span class="comment"># 其他语言的多态只能传一个类的子类</span>        <span class="comment"># 如果传入的pet参数是Pet类型为真</span>        <span class="comment"># isinstance(obj,类) -----&gt;判断obj是不是类的对象或者判断obj是不是该子类的对象</span>        <span class="keyword">if</span> <span class="built_in">isinstance</span>(pet, Pet):            <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;喜欢养宠物&#123;&#125;，昵称是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.name, pet.role, pet.nickname))        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">&#x27;不是宠物类型。。。。&#x27;</span>)<span class="keyword">class</span> <span class="title class_">Pet</span>:    role = <span class="string">&#x27;&#x27;</span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nickname, age</span>):        <span class="variable language_">self</span>.nickname = nickname        <span class="variable language_">self</span>.age = age    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;昵称：&#123;&#125;，年龄：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>.nickname, <span class="variable language_">self</span>.age))<span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Pet</span>):    role = <span class="string">&#x27;猫&#x27;</span>    <span class="keyword">def</span> <span class="title function_">catch_mouse</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;抓老鼠....&#x27;</span>)<span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Pet</span>):    role = <span class="string">&#x27;狗&#x27;</span>    <span class="keyword">def</span> <span class="title function_">whach_house</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;看家高手....&#x27;</span>)<span class="keyword">class</span> <span class="title class_">Tiger</span>:    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;太可怕了，能吃人&#x27;</span>)<span class="comment"># 创建对象</span>cat = Cat(<span class="string">&#x27;花花&#x27;</span>, <span class="number">2</span>)dog = Dog(<span class="string">&#x27;大黄&#x27;</span>, <span class="number">4</span>)person = Person(<span class="string">&#x27;小明&#x27;</span>)person.feed_pet(cat)<span class="built_in">print</span>(<span class="string">&#x27;-------------&#x27;</span>)person = Person(<span class="string">&#x27;小花&#x27;</span>)person.feed_pet(Tiger)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">pet     父类  cat  dog 子类</span><span class="string">pet     大类型 cat </span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight plaintext">回顾：面向对象的特点：封装，继承，多态封装：私有化属性：定义公有的set和get方法class Student    def __init__(self):        self.__age=age    @property    def age(self):        return self.__age    @age.setter  装饰器，防止下面将上面覆盖    def age(self,age):        self.__age=ages = Student()s.age = 10继承：父类中私有的，子类无法继承is a:    父类  子类    class Student(Person):        passhas a:    class Student:        def __init__(self,book,computer):            book是自定义类型  --- 系统类型    s = Student()多继承：class C(A,B):    pass广度优先 从上到下查看搜索顺序C.__mro__多态：class Person：    def feed_pet(self,cat):        isinstance(pet,Pet)判断参数是否是哪个类            pass</code></pre><pre><code class="highlight python"><span class="comment"># -*- Codeing = utf-8 -*-</span><span class="comment"># @Time : 2021-12-17 下午 11:58</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : test.py</span><span class="comment"># @Software : PyCharm</span><span class="keyword">class</span> <span class="title class_">Person</span>:    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="variable language_">self</span>.__money = <span class="number">200</span>        <span class="variable language_">self</span>.name = <span class="string">&#x27;匿名&#x27;</span>    <span class="keyword">def</span> <span class="title function_">show1</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="variable language_">self</span>.name, <span class="variable language_">self</span>.__money)<span class="keyword">class</span> <span class="title class_">Studen</span>(<span class="title class_ inherited__">Person</span>):    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="built_in">super</span>().__init__()        <span class="built_in">super</span>(Studen, <span class="variable language_">self</span>).__init__()        Person().__init__()<span class="comment"># 用的少</span>        <span class="variable language_">self</span>.__money = <span class="number">100</span>    <span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&#x27;money:&#x27;</span>, <span class="variable language_">self</span>.__money)s = Studen()s.show()s.show1()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 2021.3、PyCharm永久激活</title>
      <link href="/posts/366baac0.html"/>
      <url>/posts/366baac0.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>今天我安装PyCharm和IDEA的时候专业版的时候发现之前的激活方法已经失效了，于是，我花了两个小时在网上找到了。两种插件激活方法，这两种都是比较新的，</p><p>第一个插件<code>FineAgent</code>（作者好像把这项目停了，但是还可以使用）</p><p>第二种<code>ja-netfilter</code>Z大开发的（2021.11.30号发布） </p><p>接下来我就以Z大的插件来写一个教程</p></blockquote><h2 id="插件地址：热心大佬，随便选择一个进入"><a href="#插件地址：热心大佬，随便选择一个进入" class="headerlink" title="插件地址：热心大佬，随便选择一个进入"></a><a href="https://jetbra.in/s">插件地址：热心大佬</a>，随便选择一个进入</h2><p>  <img src="/posts/366baac0/image-20220727183739894.png" alt="image-20220727183739894"></p><h2 id="如果不能进入，按照下面操作进入"><a href="#如果不能进入，按照下面操作进入" class="headerlink" title="如果不能进入，按照下面操作进入"></a>如果不能进入，按照下面操作进入</h2><p> <img src="/posts/366baac0/image-20220727183848825.png" alt="image-20220727183848825"></p><h2 id="最后下载左上角这个文件，解压到你想安装的目录，记住这个目录"><a href="#最后下载左上角这个文件，解压到你想安装的目录，记住这个目录" class="headerlink" title="最后下载左上角这个文件，解压到你想安装的目录，记住这个目录"></a>最后下载左上角这个文件，解压到你想安装的目录，记住这个目录</h2><p> <img src="/posts/366baac0/image-20220727183720681.png" alt="image-20220727183720681"></p><h1 id="1、在jetbrains的官网下载并安装PyCharm或idea"><a href="#1、在jetbrains的官网下载并安装PyCharm或idea" class="headerlink" title="1、在jetbrains的官网下载并安装PyCharm或idea"></a>1、在jetbrains的官网下载并安装PyCharm或idea</h1><blockquote><p><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p></blockquote><h1 id="2、安装应用程序"><a href="#2、安装应用程序" class="headerlink" title="2、安装应用程序"></a>2、安装应用程序</h1><p>1）安装之后找到<code>bin</code>目录下以<code>*.exe.vmoptions</code>结尾的文件（例如<code>idea64.exe.vmoptions</code>），以记事本打开，在最后一行添加</p><p>2）如果之前已经安装好那么在<code>C:\Users\[用户名]\AppData\Roaming\JetBrains</code>目录下找以<code>*.exe.vmoptions</code>结尾的文件（例如<code>idea64.exe.vmoptions</code>）</p><pre><code class="highlight plaintext">--add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED--add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED#注意下面路径填写你之前下载文件的解压路径，加载ja-netfilter.jar-javaagent:D:/Program Files/JetBrains/ja-netfilter/ja-netfilter.jar=jetbrains</code></pre><h1 id="3、然后在上面下载插件的那个地址复制对应软件的激活码就好了"><a href="#3、然后在上面下载插件的那个地址复制对应软件的激活码就好了" class="headerlink" title="3、然后在上面下载插件的那个地址复制对应软件的激活码就好了"></a>3、然后在上面下载插件的那个地址复制对应软件的激活码就好了</h1><p><img src="/posts/366baac0/jetbrains-20250316230919131.png"></p><h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><h2 id="ja-netfilter"><a href="#ja-netfilter" class="headerlink" title="ja-netfilter"></a><a href="https://gitee.com/ja-netfilter/ja-netfilter">ja-netfilter</a></h2><h2 id="插件作者：Z大-知了"><a href="#插件作者：Z大-知了" class="headerlink" title="插件作者：Z大(知了)"></a><a href="https://zhile.io/">插件作者：Z大(知了)</a></h2>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 激活 </tag>
            
            <tag> ider </tag>
            
            <tag> Pycharm </tag>
            
            <tag> JetBrains </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我在校园2.5</title>
      <link href="/posts/387075cf.html"/>
      <url>/posts/387075cf.html</url>
      
        <content type="html"><![CDATA[<h1 id="📲-我在校园打卡-Python"><a href="#📲-我在校园打卡-Python" class="headerlink" title="📲 我在校园打卡(Python)"></a>📲 我在校园打卡(Python)</h1><p>新版本我在校园取消了原来的token鉴权机制，改为JWSESSION进行鉴权。</p><p>我结合两个位大神的程序更改了一下源代码实现了以下功能</p><h2 id="😊目前实现"><a href="#😊目前实现" class="headerlink" title="😊目前实现"></a>😊目前实现</h2><ul><li><input checked disabled type="checkbox"> 使用自动登录的方式获取jwsession值，将jwsession储存在leanCloud </li><li><input checked disabled type="checkbox"> 增加了一言一句话，调用google翻译的api来翻译一言一句话（心灵鸡汤😂）</li><li><input checked disabled type="checkbox"> 使用PushPlus每天自动发送告诉你是否打卡成功邮件</li></ul><h2 id="🚩准备工作"><a href="#🚩准备工作" class="headerlink" title="🚩准备工作"></a>🚩准备工作</h2><p>纯python编写，需要安装第三方库<code>requests</code> <code>leancloud</code></p><h2 id="🌕依赖安装（本地测试，也可以不测试，之间上传）"><a href="#🌕依赖安装（本地测试，也可以不测试，之间上传）" class="headerlink" title="🌕依赖安装（本地测试，也可以不测试，之间上传）"></a>🌕依赖安装（本地测试，也可以不测试，之间上传）</h2><pre><code class="highlight python">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requestspip install -i https://pypi.tuna.tsinghua.edu.cn/simple leancloud</code></pre><h2 id="👌开始"><a href="#👌开始" class="headerlink" title="👌开始"></a>👌开始</h2><h3 id="1-获取-PushPlus-的-token"><a href="#1-获取-PushPlus-的-token" class="headerlink" title="1. 获取 PushPlus 的 token"></a>1. 获取 PushPlus 的 token</h3><p>微信搜索公众号“pushplus 推送加”，关注后即可生成属于自己的 token，后面需要用到</p><h3 id="2-注册leanCloud"><a href="#2-注册leanCloud" class="headerlink" title="2.注册leanCloud"></a>2.注册leanCloud</h3><p>1）<a href="https://console.leancloud.cn/apps">注册 leanCloud 账号</a></p><p>2）到控制台新建应用，应用名字随意，应用版本选择 <strong>开发版</strong></p><p>3）进入应用，点击左侧的“数据存储 ➡ 结构化数据”，新建 Class：名称为“Info”，Class 访问权限为“所有用户”，下面的 ACL 权限选择“限制写入”</p><p>4）进入刚才创建的 Class，添加新列，值为“jwsession”，之后添加新行，注意这时候 objectId 会有一个值。如果你知道如何抓包获取自己的 jwsession，则可以填入 jwsession 值，否则可以随便填。</p><p>5）点击左侧的“设置 ➡ 应用凭证”，记住 appId 和 masterKey（<strong>请务必自己保管好，不要泄露</strong>） 的值，待会需要用到</p><h4 id="3-创建云函数"><a href="#3-创建云函数" class="headerlink" title="3. 创建云函数"></a>3. 创建云函数</h4><p>1）注册腾讯云账号并登录，进行实名认证</p><p>2）到 <a href="https://console.cloud.tencent.com/scf/list?rid=1&ns=default">https://console.cloud.tencent.com/scf/list?rid=1&amp;ns=default</a> ，选择 “新建云函数” ➔ “自定义创建”，提交方法，可以直接在线编辑然后将代码复制里面，然后点击完成就创建好了</p><h4 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h4><p>到刚才新创建的云函数中，打开代码配置文件进行修改。</p><p>1）“我在校园”账号配置项说明：</p><ul><li><code>username</code>：“我在校园”的账号，一般是你的手机号码</li><li><code>password</code>：“我在校园”的密码，忘记了打开小程序重新设置就行</li><li><code>temperature</code>：默认上报的体温为 36°C，如果你想随机上报体温，请以“36~38”的形式填写</li><li><code>city</code>：你学校所在的城市</li><li><code>school</code>：你学校的名字</li></ul><p>2）“pushPlus” 账号配置项说明：</p><ul><li><code>isEnable</code>：默认 <code>false</code>，表示不开启消息提醒功能，若要开启请修改为 <code>true</code></li><li><code>notifyToken</code>：之前你从 pushPlus 公众号那里获取的 token</li></ul><p>3）“leanCloud” 账号配置项说明：</p><ul><li><code>appId</code>：之前在 leanCloud 获取的 appId</li><li><code>masterKey</code>：之前在 leanCloud 获取的 masterKey</li></ul><h4 id="5-安装-leanCloud-库"><a href="#5-安装-leanCloud-库" class="headerlink" title="5. 安装 leanCloud 库"></a>5. 安装 leanCloud 库</h4><p>到刚才新创建的云函数中，<code>ctrl + shift + ~</code> 新建终端，cd 进入 <code>index.py</code> 所在的文件夹中，通过如下命令安装 leanCloud 库：</p><pre><code class="highlight plaintext">pip3 install leancloud -t .</code></pre><p>可能会报错，主要是因为相关库版本不匹配的问题，不影响正常使用。看到 <code>successfully installed</code> 就说明安装成功了。</p><h2 id="代码段-云函数"><a href="#代码段-云函数" class="headerlink" title="代码段(云函数)"></a>代码段(云函数)</h2><pre><code class="highlight python"><span class="comment"># -*- Codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/11/5 8:12</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : 健康打卡2.5.py</span><span class="comment"># @Software : PyCharm</span><span class="keyword">import</span> json<span class="keyword">import</span> logging<span class="keyword">import</span> random<span class="keyword">import</span> requests<span class="keyword">import</span> time<span class="keyword">import</span> datetime<span class="keyword">import</span> leancloud<span class="comment"># 将你的账号和密码写在下面引号内</span>username = <span class="string">&quot;&quot;</span>password = <span class="string">&quot;&quot;</span><span class="comment"># 修改此处token值，打开官网扫码点击一对一就可以看见token值：http://www.pushplus.plus/ 将获取到的token值填写在下面引号内</span>token = <span class="string">&#x27;&#x27;</span><span class="comment"># leancloud的appId和key值</span>appId = <span class="string">&quot;&quot;</span>masterKey = <span class="string">&quot;&quot;</span>logger = logging.getLogger()logger.setLevel(logging.INFO)<span class="keyword">class</span> <span class="title class_">leanCloudss</span>:    <span class="comment"># 初始化 leanCloud 对象</span>    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        leancloud.init(appId, master_key=masterKey)        <span class="variable language_">self</span>.obj = leancloud.Query(<span class="string">&#x27;Info&#x27;</span>).first()    <span class="comment"># 获取 jwsession</span>    <span class="keyword">def</span> <span class="title function_">getJwsession</span>(<span class="params">self</span>):        <span class="keyword">return</span> <span class="variable language_">self</span>.obj.get(<span class="string">&#x27;jwsession&#x27;</span>)    <span class="comment"># 设置 jwsession</span>    <span class="keyword">def</span> <span class="title function_">setJwsession</span>(<span class="params">self, jwsession</span>):        <span class="variable language_">self</span>.obj.<span class="built_in">set</span>(<span class="string">&#x27;jwsession&#x27;</span>, jwsession)        <span class="variable language_">self</span>.obj.save()<span class="comment"># 自动登录获取jwsession值</span><span class="keyword">class</span> <span class="title class_">WoZaiXiaoYuanPuncher</span>:    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="comment"># JWSESSION</span>        <span class="variable language_">self</span>.jwsession = <span class="literal">None</span>        <span class="comment"># 打卡结果</span>        <span class="variable language_">self</span>.status_code = <span class="number">0</span>        <span class="comment"># 登陆接口</span>        <span class="variable language_">self</span>.loginUrl = <span class="string">&quot;https://gw.wozaixiaoyuan.com/basicinfo/mobile/login/username&quot;</span>        <span class="comment"># 请求头</span>        <span class="variable language_">self</span>.header = &#123;            <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,            <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.13(0x18000d32) NetType/WIFI Language/zh_CN miniProgram&quot;</span>,            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,            <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;2&quot;</span>,            <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;gw.wozaixiaoyuan.com&quot;</span>,            <span class="string">&quot;Accept-Language&quot;</span>: <span class="string">&quot;en-us,en&quot;</span>,            <span class="string">&quot;Accept&quot;</span>: <span class="string">&quot;application/json, text/plain, */*&quot;</span>        &#125;        <span class="comment"># 请求体（必须有）</span>        <span class="variable language_">self</span>.body = <span class="string">&quot;&#123;&#125;&quot;</span>    <span class="comment"># 登录</span>    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):        url = <span class="string">f&#x27;<span class="subst">&#123;self.loginUrl&#125;</span>?username=<span class="subst">&#123;username&#125;</span>&amp;password=<span class="subst">&#123;password&#125;</span>&#x27;</span>        <span class="variable language_">self</span>.session = requests.session()        <span class="comment"># 登录</span>        response = <span class="variable language_">self</span>.session.post(url=url, data=<span class="variable language_">self</span>.body, headers=<span class="variable language_">self</span>.header)        res = json.loads(response.text)        <span class="keyword">if</span> res[<span class="string">&quot;code&quot;</span>] == <span class="number">0</span>:            <span class="built_in">print</span>(<span class="string">&quot;使用账号信息登录成功&quot;</span>)            jwsession = response.headers[<span class="string">&#x27;JWSESSION&#x27;</span>]            <span class="keyword">return</span> jwsession        <span class="keyword">else</span>:            <span class="built_in">print</span>(res)            <span class="built_in">print</span>(<span class="string">&quot;登录失败，请检查账号信息&quot;</span>)            <span class="variable language_">self</span>.status_code = <span class="number">5</span>            <span class="keyword">return</span> <span class="literal">False</span><span class="keyword">class</span> <span class="title class_">Custom</span>:    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="keyword">pass</span>    <span class="comment"># 调用一言一句话</span>    <span class="keyword">def</span> <span class="title function_">YiYan</span>(<span class="params">self</span>):        data = &#123;            <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;j&#x27;</span>,            <span class="string">&#x27;encode&#x27;</span>: <span class="string">&#x27;text&#x27;</span>,            <span class="string">&#x27;charset&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>,        &#125;        HitokotoUrl = <span class="string">&#x27;https://v1.hitokoto.cn/&#x27;</span>        YiJvHua = requests.get(url=HitokotoUrl, params=(data)).text        <span class="comment"># url_google = &#x27;http://xy1314.xyz/API/Google/api.php?msg=&#123;&#125;&amp;b=en&#x27;.format(YiJvHua)</span>        <span class="comment"># translation = requests.get(YiJvHua).text</span>        <span class="keyword">return</span> YiJvHua    <span class="comment"># 调用PushPlus</span>    <span class="keyword">def</span> <span class="title function_">PushPlus</span>(<span class="params">self, text</span>):        data = &#123;            <span class="string">&quot;title&quot;</span>: <span class="string">&quot;我在校园&quot;</span>,            <span class="string">&quot;content&quot;</span>: <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(text),            <span class="string">&quot;template&quot;</span>: <span class="string">&quot;json&quot;</span>        &#125;        PushPlus_Url = <span class="string">&quot;http://www.pushplus.plus/send?token=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(token)        result = requests.get(PushPlus_Url, params=(data)).text        <span class="keyword">return</span> result<span class="comment"># 判度是否返回的code来推送消息</span><span class="keyword">def</span> <span class="title function_">get_status</span>(<span class="params">self</span>):    Send_News = Custom()    <span class="keyword">if</span> <span class="variable language_">self</span>[<span class="string">&#x27;code&#x27;</span>] == <span class="number">0</span>:        text = <span class="string">&quot;哥哥帮你打卡成功了呦！！送哥哥一句话：&lt;br&gt;&lt;br&gt;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(Send_News.YiYan())        <span class="keyword">return</span> Send_News.PushPlus(text)    <span class="keyword">elif</span> <span class="variable language_">self</span>[<span class="string">&#x27;code&#x27;</span>] == <span class="number">1</span>:        text = <span class="string">&quot;健康打卡已经结束了哦！！！&quot;</span>        <span class="keyword">return</span> Send_News.PushPlus(text + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + Send_News.YiYan())    <span class="keyword">elif</span> <span class="variable language_">self</span>[<span class="string">&#x27;code&#x27;</span>] == -<span class="number">10</span>:        text = <span class="string">&quot;···jwsession已失效&quot;</span>        <span class="keyword">return</span> Send_News.PushPlus(text + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + Send_News.YiYan())    <span class="keyword">else</span>:        text = <span class="string">&quot;！！！发生未知错误&quot;</span>        <span class="keyword">return</span> Send_News.PushPlus(text + <span class="string">&#x27;&lt;br&gt;&#x27;</span> + Send_News.YiYan())<span class="keyword">class</span> <span class="title class_">answer</span>:    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):        <span class="variable language_">self</span>.api = <span class="string">&quot;https://student.wozaixiaoyuan.com/health/save.json&quot;</span>        <span class="variable language_">self</span>.headers = &#123;            <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;student.wozaixiaoyuan.com&quot;</span>,            <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,            <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;gzip, deflate, br&quot;</span>,            <span class="string">&quot;Connection&quot;</span>: <span class="string">&quot;keep-alive&quot;</span>,            <span class="comment"># 修改5：User-Agent</span>            <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36 MicroMessenger/7.0.9.501 NetType/WIFI MiniProgramEnv/Windows WindowsWechat&quot;</span>,            <span class="comment"># 修改6：Referer</span>            <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://servicewechat.com/wxce6d08f781975d91/181/page-frame.html&quot;</span>,            <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;360&quot;</span>,            <span class="string">&quot;JWSESSION&quot;</span>: <span class="string">&quot;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(leanCloudss().getJwsession())        &#125;        <span class="variable language_">self</span>.data = &#123;            <span class="string">&quot;answers&quot;</span>: <span class="string">&#x27;[&quot;0&quot;,&quot;1&quot;,&quot;36.5&quot;,&quot;无&quot;]&#x27;</span>,            <span class="comment"># 修改8：打卡地址</span>            <span class="string">&quot;longitude&quot;</span>: <span class="string">&quot;109.02697&quot;</span>,  <span class="comment"># 经度</span>            <span class="string">&quot;latitude&quot;</span>: <span class="string">&quot;32.6955&quot;</span>,  <span class="comment"># 纬度</span>            <span class="string">&quot;country&quot;</span>: <span class="string">&quot;中国&quot;</span>,            <span class="string">&quot;province&quot;</span>: <span class="string">&quot;陕西省&quot;</span>,            <span class="string">&quot;city&quot;</span>: <span class="string">&quot;西安市&quot;</span>,            <span class="string">&quot;district&quot;</span>: <span class="string">&quot;**区&quot;</span>,            <span class="string">&quot;township&quot;</span>: <span class="string">&quot;**街道&quot;</span>,            <span class="string">&quot;street&quot;</span>: <span class="string">&quot;***路&quot;</span>,            <span class="string">&quot;areacode&quot;</span>: <span class="string">&quot;1111111&quot;</span>,        &#125;    <span class="keyword">def</span> <span class="title function_">get_seq</span>(<span class="params">self</span>):        current_hour = datetime.datetime.now()        current_hour = current_hour.hour + <span class="number">8</span>        <span class="keyword">if</span> <span class="number">0</span> &lt;= current_hour &lt;= <span class="number">18</span>:            <span class="keyword">return</span> <span class="number">0</span>        <span class="keyword">else</span>:            <span class="keyword">return</span> <span class="number">1</span>    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):        <span class="built_in">print</span>(<span class="string">&quot;JWSESSION:&quot;</span> + <span class="variable language_">self</span>.headers[<span class="string">&quot;JWSESSION&quot;</span>])        <span class="built_in">print</span>(<span class="string">&#x27;当前时间为：&#x27;</span>, datetime.datetime.now())        <span class="variable language_">self</span>.res = requests.post(<span class="variable language_">self</span>.api, headers=<span class="variable language_">self</span>.headers, data=<span class="variable language_">self</span>.data, ).json()  <span class="comment"># 打卡提交</span>        time.sleep(<span class="number">1</span>)        <span class="built_in">print</span>(<span class="variable language_">self</span>.res)        <span class="keyword">if</span> <span class="variable language_">self</span>.res[<span class="string">&#x27;code&#x27;</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="variable language_">self</span>.res[<span class="string">&#x27;code&#x27;</span>] != <span class="number">1</span>:            leanClouds().setJwsession(WoZaiXiaoYuanPuncher().login())            get_status(<span class="variable language_">self</span>.res)            <span class="keyword">return</span> <span class="literal">False</span>        <span class="keyword">else</span>:            get_status(<span class="variable language_">self</span>.res)            <span class="keyword">return</span> <span class="literal">True</span><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:    <span class="keyword">if</span> answer().run():        <span class="keyword">pass</span>    <span class="keyword">else</span>:        answer().run()<span class="keyword">def</span> <span class="title function_">main_handler</span>(<span class="params">event, context</span>):    logger.info(<span class="string">&#x27;got event&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(event))    <span class="keyword">return</span> answer().run()</code></pre><h2 id="📢-声明"><a href="#📢-声明" class="headerlink" title="📢 声明"></a>📢 声明</h2><ol><li>本项目仅供编程学习&#x2F;个人使用，请遵守Apache-2.0 License开源项目授权协议。</li><li>请在国家法律法规和校方相关原则下使用。</li><li>开发者不对任何下载者和使用者的任何行为负责。</li><li>本程序无任何后门，所有数据仅存留于使用者机器上。 </li><li>请不要轻易将自己的账号信息告诉他人。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>phpstudy和windows_mysql_冲突解决办法</title>
      <link href="/posts/d114782d.html"/>
      <url>/posts/d114782d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、删除自己在电脑上安装的mysql服务"><a href="#1、删除自己在电脑上安装的mysql服务" class="headerlink" title="1、删除自己在电脑上安装的mysql服务"></a>1、删除自己在电脑上安装的mysql服务</h1><p>Win+X，管理员打开windows终端然后输入命令，<code>PS：如果你没有添加mysql环境变量，那么你需要进入mysql中的bin目录里面打开终端</code></p><p><img src="/posts/d114782d/image-20211115174131632.webp" alt="image-20211115174131632"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">先停止你的mysql服务</span>net stop mysqlmysqld -remove</code></pre><h1 id="2、打开phpstudy启动mysql"><a href="#2、打开phpstudy启动mysql" class="headerlink" title="2、打开phpstudy启动mysql"></a>2、打开phpstudy启动mysql</h1><p>点击启动就可以启动了</p><p><img src="/posts/d114782d/image-20211115174500274.webp" alt="image-20211115174500274"></p><h1 id="3、创建新的mysql服务，服务名称重新命名"><a href="#3、创建新的mysql服务，服务名称重新命名" class="headerlink" title="3、创建新的mysql服务，服务名称重新命名"></a>3、创建新的mysql服务，服务名称重新命名</h1><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">新建myql服务名称</span>mysqld install sql<span class="meta prompt_"># </span><span class="language-bash">启动mysql服务，你就可以打开你原来的mysql数据库了</span>net start slq</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python魔术方法</title>
      <link href="/posts/b87b8b00.html"/>
      <url>/posts/b87b8b00.html</url>
      
        <content type="html"><![CDATA[<h1 id="python-魔术方法"><a href="#python-魔术方法" class="headerlink" title="python 魔术方法"></a>python 魔术方法</h1><h1 id="常用魔术方法"><a href="#常用魔术方法" class="headerlink" title="常用魔术方法"></a>常用魔术方法</h1><hr><blockquote><p>魔术方法就是一个类&#x2F;对象中的方法，和普通方法唯一的不同时，普通方法需要调用！而魔术方法是在特定时刻自动触发。</p></blockquote><h4 id="1-init"><a href="#1-init" class="headerlink" title="1.init"></a>1.<strong>init</strong></h4><pre><code class="highlight plaintext">初始化魔术方法触发时机：初始化对象时触发（不是实例化触发，但是和实例化在一个操作中）参数：至少有一个self，接收对象返回值：无作用：初始化对象的成员注意：使用该方式初始化的成员都是直接写入对象当中，类中无法具有</code></pre><h4 id="2-new"><a href="#2-new" class="headerlink" title="2.new"></a>2.<strong>new</strong></h4><pre><code class="highlight plaintext">实例化魔术方法触发时机： 在实例化对时触发参数：至少一个cls 接收当前类返回值：必须返回一个对象实例作用：实例化对象注意：实例化对象是Object类底层实现，其他类继承了Object的__new__才能够实现实例化对象。没事别碰这个魔术方法，先触发__new__才会触发__init__</code></pre><h4 id="3-del"><a href="#3-del" class="headerlink" title="3.del"></a>3.<strong>del</strong></h4><pre><code class="highlight plaintext">析构魔术方法触发时机：当对象没有用（没有任何变量引用）的时候被触发参数：一个self 结婚搜对象返回值：无作用：使用完对象是回收资源注意：del不一定会触发当前方法，只有当前对象没有任何变量接收时才会触发</code></pre><h4 id="4-call"><a href="#4-call" class="headerlink" title="4.call"></a>4.<strong>call</strong></h4><pre><code class="highlight plaintext">调用对象的魔术方法触发时机:将对象当作函数调用时触发 对象()参数:至少一个self接收对象，其余根据调用时参数决定返回值：根据情况而定作用：可以将复杂的步骤进行合并操作，减少调用的步骤，方便使用注意：无</code></pre><h4 id="5-len"><a href="#5-len" class="headerlink" title="5.len"></a>5.<strong>len</strong></h4><pre><code class="highlight plaintext">触发时机：使用len(对象) 的时候触发参数：一个参数self返回值：必须是一个整型作用：可以设置为检测对象成员个数，但是也可以进行其他任意操作注意：返回值必须必须是整数，否则语法报错，另外该要求是格式要求。</code></pre><h4 id="6-str"><a href="#6-str" class="headerlink" title="6.str"></a>6.<strong>str</strong></h4><pre><code class="highlight plaintext">触发时机:使用print(对象)或者str(对象)的时候触发参数：一个self接收对象返回值：必须是字符串类型作用：print（对象时）进行操作，得到字符串，通常用于快捷操作注意：无</code></pre><h4 id="7-repr"><a href="#7-repr" class="headerlink" title="7.repr"></a>7.<strong>repr</strong></h4><pre><code class="highlight plaintext">触发时机:在使用repr(对象)的时候触发参数：一个self接收对象返回值：必须是字符串作用：将对象转使用repr化为字符串时使用，也可以用于快捷操作</code></pre><blockquote><p>repr函数和str函数处理字符串只有一个区别：</p><p>str的结果 字符串本身 （结果可以被eval执行）</p><p>如：x &#x3D; ‘无图言Diao’ str() -&gt;无图言Diao</p><p>rerpr的结果 字符串定义结构 （eavl不会执行repr结果）</p><p>如：x &#x3D; ‘无图言Diao’ repr() -&gt;’无图言Diao’</p><p>备注: 在类中通常情况下__str__和__repr__ 设置相同即可</p><p>eval()</p><p>函数 将字符串当作python代码执行</p><p>格式：eval(字符串)</p><p>返回值：可以有返回值</p></blockquote><h4 id="8-bool"><a href="#8-bool" class="headerlink" title="8.bool"></a>8.<strong>bool</strong></h4><pre><code class="highlight plaintext">触发时机: 使用bool(对象)的时候触发参数：一个self接收对象返回值：必须是布尔值作用：根据实际情况决定，可以作为快捷方式使用注意:仅适合于返回布尔值的操作</code></pre><h4 id="9-format"><a href="#9-format" class="headerlink" title="9.format"></a>9.<strong>format</strong></h4><pre><code class="highlight plaintext">触发时机：使用字符串.format(对象)时候触发参数：一个self接收对象，一个参数接收format的&#123;&#125;中的格式，例如:&gt;5返回值:必须是字符串作用：设置对象可以作为format的参数，并且自定义对象格式化的规则注意：无</code></pre><h1 id="描述符相关的魔术方法"><a href="#描述符相关的魔术方法" class="headerlink" title="描述符相关的魔术方法"></a>描述符相关的魔术方法</h1><hr><h4 id="1-get"><a href="#1-get" class="headerlink" title="1.get()"></a>1.<strong>get</strong>()</h4><pre><code class="highlight plaintext">触发时机：在获取指定描述符操作的成员属性的值的时候触发参数：1描述符对象本身，2描述符描述的属性所在的对象，描述符描述的对象的类返回值：必须有，不然无法获取相应属性值注意：仅在描述符中使用</code></pre><h4 id="2-set"><a href="#2-set" class="headerlink" title="2.set()"></a>2.<strong>set</strong>()</h4><pre><code class="highlight plaintext">触发时机：在设置或者添加指定描述符操作的成员属性的时候触发参数：1描述符对象本身，2描述符描述的属性所在的对象,3要设置的值返回值：无注意：仅在描述符中使用</code></pre><h4 id="3-delete"><a href="#3-delete" class="headerlink" title="3.delete()"></a>3.<strong>delete</strong>()</h4><pre><code class="highlight plaintext">触发时机：在删除指定描述符操作的成员属性的时候触发参数：1描述符对象本身，2描述符描述的属性所在的对象返回值：无注意：仅在描述符中使用</code></pre><h1 id="与属性操作相关的魔术方法"><a href="#与属性操作相关的魔术方法" class="headerlink" title="与属性操作相关的魔术方法"></a>与属性操作相关的魔术方法</h1><hr><h4 id="1-getattr（）"><a href="#1-getattr（）" class="headerlink" title="1.getattr（）"></a>1.<strong>getattr</strong>（）</h4><pre><code class="highlight plaintext">触发时机：获取不存在的对象成员时触发参数：1接收当前对象的self，一个是获取成员名称的字符串返回值：必须有值作用:为访问不存在的属性设置值注意：getattribute无论何时都会在getattr之前触发，触发了getattribute就不会在触发getattr了</code></pre><h4 id="2-setattr（）"><a href="#2-setattr（）" class="headerlink" title="2.setattr（）"></a>2.<strong>setattr</strong>（）</h4><pre><code class="highlight plaintext">触发时机:设置对象成员值的时候触发参数:1个当前对象的self,一个是要设置的成员名称字符串,一个是要设置的值返回值:无 过程操作作用:接管设置操作,可以在设置前之前进行判断验证等行为注意:在当前方法中无法使用成员=值的方式直接设置成员，否则会无限递归，必须借助object的设置方法来完成object.__setattr__（参数1，参数2，参数3）</code></pre><h4 id="3-delattr（）"><a href="#3-delattr（）" class="headerlink" title="3.delattr（）"></a>3.<strong>delattr</strong>（）</h4><pre><code class="highlight plaintext">触发时机：删除对象成员时触发参数：一个当前对象的self返回值：无作用:可以在删除成员时进行验证。</code></pre><h4 id="4-getattribute（）"><a href="#4-getattribute（）" class="headerlink" title="4.getattribute（）"></a>4.<strong>getattribute</strong>（）</h4><pre><code class="highlight plaintext">触发时机：使用对象成员时触发，无论成员是否存在参数：1个接收当前对象self，一个是获取的成员的名称字符串返回值：必须有作用：在具有封装操作（私有化时），为程序开部分访问权限使用</code></pre><h4 id="5-dir（）"><a href="#5-dir（）" class="headerlink" title="5.dir（）"></a>5.<strong>dir</strong>（）</h4><pre><code class="highlight plaintext">触发时机：dir（对象）的时候触发参数:1个接收当前对象self返回值：必须为序列类型（列表，元组，集合等，）作用：可以自定义成员列表的返回值</code></pre><h1 id="运算相关魔术方法-上帝模式"><a href="#运算相关魔术方法-上帝模式" class="headerlink" title="运算相关魔术方法(上帝模式)"></a>运算相关魔术方法(上帝模式)</h1><hr><h2 id="比较运算相关魔术方法"><a href="#比较运算相关魔术方法" class="headerlink" title="比较运算相关魔术方法"></a>比较运算相关魔术方法</h2><hr><h4 id="1-lt"><a href="#1-lt" class="headerlink" title="1.lt()"></a>1.<strong>lt</strong>()</h4><pre><code class="highlight plaintext">格式：    def __lt__(self,other):    return 数据特征：    触发时机：进行小于判断时自动触发    参数：2个参数第一个是self，第二个判断的第二个对象    返回值：返回值可以任意类型，推荐布尔值    作用：定义小于号的行为：x &lt; y 调用 x.lt(y)</code></pre><h4 id="2-le"><a href="#2-le" class="headerlink" title="2.le()"></a>2.<strong>le</strong>()</h4><pre><code class="highlight plaintext">格式：    def __le__(self):    return str特征：    触发时机：进行小于等于判断时自动触发    参数：2个参数第一个是self，第二个判断的第二个对象    返回值：返回值可以任意类型，推荐布尔值    作用：定义小于等于号的行为：x &lt;= y 调用 x.le(y)</code></pre><h4 id="3-gt"><a href="#3-gt" class="headerlink" title="3.gt()"></a>3.<strong>gt</strong>()</h4><pre><code class="highlight plaintext">格式：    def __gt__(self):    return str特征：    触发时机：进行大于判断时自动触发    参数：2个参数第一个是self，第二个判断的第二个对象    返回值：返回值可以任意类型，推荐布尔值    作用：定义大于号的行为：x &gt; y 调用 x.gt(y)</code></pre><h4 id="4-ge"><a href="#4-ge" class="headerlink" title="4.ge()"></a>4.<strong>ge</strong>()</h4><pre><code class="highlight plaintext">格式：    def __ge__(self):    return str特征：    触发时机：进行大于等于判断时自动触发    参数：2个参数第一个是self，第二个判断的第二个对象    返回值：返回值可以任意类型，推荐布尔值    作用：定义大于等于号的行为：x &gt;= y 调用 x.ge(y)</code></pre><h4 id="5-eq"><a href="#5-eq" class="headerlink" title="5.eq()"></a>5.<strong>eq</strong>()</h4><pre><code class="highlight plaintext">格式：    def __eq__(self):    return str特征：    触发时机：进行等于判断时自动触发    参数：2个参数第一个是self，第二个判断的第二个对象    返回值：返回值可以任意类型，推荐布尔值    作用：定义大于等于号的行为：x == y 调用 x.eq(y)</code></pre><h4 id="6-ne"><a href="#6-ne" class="headerlink" title="6.ne()"></a>6.<strong>ne</strong>()</h4><pre><code class="highlight plaintext">格式：    def __ne__(self):    return str特征：    触发时机：进行不等于判断时自动触发    参数：2个参数第一个是self，第二个判断的第二个对象    返回值：返回值可以任意类型，推荐布尔值    作用：定义不等号的行为：x != y 调用 x.ne(y)</code></pre><h2 id="算术运算相关魔术方法"><a href="#算术运算相关魔术方法" class="headerlink" title="算术运算相关魔术方法"></a>算术运算相关魔术方法</h2><hr><pre><code class="highlight python">__add__(<span class="variable language_">self</span>, other)           定义加法的行为：+__sub__(<span class="variable language_">self</span>, other)           定义减法的行为：-__mul__(<span class="variable language_">self</span>, other)           定义乘法的行为：__truediv__(<span class="variable language_">self</span>, other)       定义真除法的行为：/__floordiv__(<span class="variable language_">self</span>, other)      定义整数除法的行为：//__mod__(<span class="variable language_">self</span>, other)           定义取模算法的行为：%__divmod__(<span class="variable language_">self</span>, other)        定义当被 <span class="built_in">divmod</span>() 调用时的行为__pow__(<span class="variable language_">self</span>, other[, modulo]) 定义当被 power() 调用或 ** 运算时的行为__lshift__(<span class="variable language_">self</span>, other)        定义按位左移位的行为：&lt;&lt;__rshift__(<span class="variable language_">self</span>, other)        定义按位右移位的行为：&gt;&gt;__and__(<span class="variable language_">self</span>, other)           定义按位与操作的行为：&amp;__xor__(<span class="variable language_">self</span>, other)           定义按位异或操作的行为：^__or__(<span class="variable language_">self</span>, other)            定义按位或操作的行为：|</code></pre><h2 id="反运算相关魔术方法"><a href="#反运算相关魔术方法" class="headerlink" title="反运算相关魔术方法"></a>反运算相关魔术方法</h2><hr><pre><code class="highlight python">__radd__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__rsub__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__rmul__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__rtruediv__(<span class="variable language_">self</span>, other)  与上方相同，当左操作数不支持相应的操作时被调用__rfloordiv__(<span class="variable language_">self</span>, other) 与上方相同，当左操作数不支持相应的操作时被调用__rmod__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__rdivmod__(<span class="variable language_">self</span>, other)   与上方相同，当左操作数不支持相应的操作时被调用__rpow__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__rlshift__(<span class="variable language_">self</span>, other)   与上方相同，当左操作数不支持相应的操作时被调用__rrshift__(<span class="variable language_">self</span>, other)   与上方相同，当左操作数不支持相应的操作时被调用__rand__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__rxor__(<span class="variable language_">self</span>, other)      与上方相同，当左操作数不支持相应的操作时被调用__ror__(<span class="variable language_">self</span>, other)       与上方相同，当左操作数不支持相应的操作时被调用</code></pre><h2 id="赋值运算相关魔术方法"><a href="#赋值运算相关魔术方法" class="headerlink" title="赋值运算相关魔术方法"></a>赋值运算相关魔术方法</h2><hr><pre><code class="highlight python">__iadd__(<span class="variable language_">self</span>, other)             定义赋值加法的行为：+=__isub__(<span class="variable language_">self</span>, other)             定义赋值减法的行为：-=__imul__(<span class="variable language_">self</span>, other)             定义赋值乘法的行为：=__itruediv__(<span class="variable language_">self</span>, other)         定义赋值真除法的行为：/=__ifloordiv__(<span class="variable language_">self</span>, other)        定义赋值整数除法的行为：//=__imod__(<span class="variable language_">self</span>, other)             定义赋值取模算法的行为：%=__ipow__(<span class="variable language_">self</span>, other[, modulo])   定义赋值幂运算的行为：**=__ilshift__(<span class="variable language_">self</span>, other)          定义赋值按位左移位的行为：&lt;&lt;=__irshift__(<span class="variable language_">self</span>, other)          定义赋值按位右移位的行为：&gt;&gt;=__iand__(<span class="variable language_">self</span>, other)             定义赋值按位与操作的行为：&amp;=__ixor__(<span class="variable language_">self</span>, other)             定义赋值按位异或操作的行为：^=__ior__(<span class="variable language_">self</span>, other)              定义赋值按位或操作的行为：|=</code></pre><h2 id="一元运算相关魔术方法"><a href="#一元运算相关魔术方法" class="headerlink" title="一元运算相关魔术方法"></a>一元运算相关魔术方法</h2><hr><pre><code class="highlight python">__pos__(<span class="variable language_">self</span>)      定义正号的行为：+x__neg__(<span class="variable language_">self</span>)      定义负号的行为：-x__abs__(<span class="variable language_">self</span>)      定义当被 <span class="built_in">abs</span>() 调用时的行为__invert__(<span class="variable language_">self</span>)   定义按位求反的行为：~x</code></pre><h2 id="类型转换相关魔术方法-JIANG"><a href="#类型转换相关魔术方法-JIANG" class="headerlink" title="类型转换相关魔术方法 JIANG"></a>类型转换相关魔术方法 JIANG</h2><hr><pre><code class="highlight python">__complex__(<span class="variable language_">self</span>)      定义当被 <span class="built_in">complex</span>() 调用时的行为（需要返回恰当的值）__int__(<span class="variable language_">self</span>)          定义当被 <span class="built_in">int</span>() 调用时的行为（需要返回恰当的值）__float__(<span class="variable language_">self</span>)        定义当被 <span class="built_in">float</span>() 调用时的行为（需要返回恰当的值）__round__(<span class="variable language_">self</span>[, n])   定义当被 <span class="built_in">round</span>() 调用时的行为（需要返回恰当的值）__index(<span class="variable language_">self</span>)__        <span class="number">1.</span> 当对象是被应用在切片表达式中时，实现整形强制转换                       <span class="number">2.</span> 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 index                       <span class="number">3.</span> 如果 index 被定义，则 <span class="built_in">int</span> 也需要被定义，且返回相同的值</code></pre><h2 id="上下文管理相关魔术方法"><a href="#上下文管理相关魔术方法" class="headerlink" title="上下文管理相关魔术方法"></a>上下文管理相关魔术方法</h2><hr><p><strong>enter</strong>() 和 <strong>exit</strong>()</p><pre><code class="highlight python">enter(<span class="variable language_">self</span>)    <span class="number">1.</span> 定义当使用 <span class="keyword">with</span> 语句时的初始化行为    <span class="number">2.</span> enter 的返回值被 <span class="keyword">with</span> 语句的目标或者 <span class="keyword">as</span> 后的名字绑定exit(<span class="variable language_">self</span>, exctype, excvalue, traceback)    <span class="number">1.</span> 定义当一个代码块被执行或者终止后上下文管理器应该做什么    <span class="number">2.</span> 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作</code></pre><h2 id="容器类型相关魔术方法"><a href="#容器类型相关魔术方法" class="headerlink" title="容器类型相关魔术方法"></a>容器类型相关魔术方法</h2><hr><pre><code class="highlight python">__len__(<span class="variable language_">self</span>)                  定义当被 <span class="built_in">len</span>() 调用时的行为（返回容器中元素的个数）__getitem__(<span class="variable language_">self</span>, key)         定义获取容器中指定元素的行为，相当于 <span class="variable language_">self</span>[key]__setitem__(<span class="variable language_">self</span>, key, value)  定义设置容器中指定元素的行为，相当于 <span class="variable language_">self</span>[key] = value__delitem__(<span class="variable language_">self</span>, key)         定义删除容器中指定元素的行为，相当于 <span class="keyword">del</span> <span class="variable language_">self</span>[key]__iter__(<span class="variable language_">self</span>)                 定义当迭代容器中的元素的行为__reversed__(<span class="variable language_">self</span>)             定义当被 <span class="built_in">reversed</span>() 调用时的行为__contains__(<span class="variable language_">self</span>, item)       定义当使用成员测试运算符（<span class="keyword">in</span> 或 <span class="keyword">not</span> <span class="keyword">in</span>）时的行为</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器与迭代器</title>
      <link href="/posts/76a3894a.html"/>
      <url>/posts/76a3894a.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/76a3894a/image-20211031232546648.webp" alt="image-20211031232546648"></p><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/10/31 11:11</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : generator01.py</span><span class="comment"># @Sofware : PyCharm</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">通过列表生成式(列表推导式)，我们可以直接创建一个列表</span><span class="string">但是，受内存限制，列表容量肯定是有限的。</span><span class="string">而且，创建一个包含100万个元素的列表，不仅占用很大的存储看见，</span><span class="string">如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了</span><span class="string">所以如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢！</span><span class="string">这样就不必创建完整的list，从而节省大量的空间，在python中，这种一边循环一边计算的机制称为生成器</span><span class="string">generator</span><span class="string"></span><span class="string">得到生成器的方式：</span><span class="string">1.通过列表推导式得到生成器</span><span class="string">2.</span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># [x for x in range(100000000)]</span><span class="comment"># [0,2,3,7,6,3,6,8,9,6,5]</span><span class="comment"># newlist = [x*3 for x in range(10)]</span><span class="comment"># print(newlist)</span><span class="comment"># 得到生成器</span>g = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))<span class="built_in">print</span>(<span class="built_in">type</span>(g))  <span class="comment"># &lt;class &#x27;generator&#x27;&gt;</span><span class="comment"># 通过调用__next__()方式得到元素</span><span class="built_in">print</span>(g.__next__())     <span class="comment"># 0</span><span class="comment"># 方式2：next(生成器对象)    builtins    系统内置函数</span><span class="comment"># 每调用一次next则会产生一个元素</span><span class="built_in">print</span>(<span class="built_in">next</span>(g))      <span class="comment"># 3</span><span class="comment"># StopIteration 生成器本来就可以产生10个，得到10个，在调用next会抛出异常</span><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/10/31 11:33</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : generator02.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment"># g = (x * 3 for x in range(10))</span><span class="comment">#</span><span class="comment"># while True:</span><span class="comment">#     try:</span><span class="comment">#         e = next(g)</span><span class="comment">#         print(e)</span><span class="comment">#     except StopIteration:</span><span class="comment">#         print(&#x27;没有更多元素了！&#x27;)</span><span class="comment">#         break</span><span class="comment"># 定义生成器的方式二：借助函数完成</span><span class="comment"># 只要函数中出现yield关键字，说明函数就不是函数，变成生成器了</span><span class="comment"># 斐波那契数列</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">步骤：</span><span class="string">1.定义一个函数，函数中使用yield关键字</span><span class="string">2.调用函数，接收调用的结果</span><span class="string">3.得到的结果就是生成器</span><span class="string">4.借助与next(),__next__得到元素</span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># def func():</span><span class="comment">#     n = 0</span><span class="comment">#     while True:</span><span class="comment">#         n += 1</span><span class="comment">#         print(n)</span><span class="comment">#         yield n  # return n + 暂停</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># a = func()</span><span class="comment"># next(a)</span><span class="comment"># next(a)</span><span class="comment"># next(a)</span><span class="comment"># a.__next__()</span><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">length</span>):    a, b = <span class="number">0</span>, <span class="number">1</span>    n = <span class="number">0</span>    <span class="keyword">while</span> n &lt; length:        <span class="comment"># print(b)</span>        <span class="keyword">yield</span> b        a, b = b, a + b        n += <span class="number">1</span>    <span class="keyword">return</span> <span class="string">&#x27;没有更多元素了！！！&#x27;</span>     <span class="comment"># return就是在得到StopIteration后的提示</span>g = fib(<span class="number">10</span>)<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="built_in">print</span>(<span class="built_in">next</span>(g))<span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/10/31 13:46</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : generator03.py</span><span class="comment"># @Sofware : PyCharm</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">生成器方法：</span><span class="string">    __next__():     获取下一个元素</span><span class="string">    send(value):    向每次生成器调用中传值 注意：第一次调用send(None)</span><span class="string"></span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">gen</span>():    i = <span class="number">0</span>    <span class="keyword">while</span> i &lt; <span class="number">5</span>:        temp = <span class="keyword">yield</span> i        <span class="built_in">print</span>(<span class="string">&#x27;temp&#x27;</span>, temp)        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(temp):            <span class="built_in">print</span>(<span class="string">&#x27;---------&#x27;</span>, x)        i += <span class="number">1</span>    <span class="keyword">return</span> <span class="string">&#x27;没有更多的数据了&#x27;</span>g = gen()<span class="comment"># print(next(g))</span><span class="comment"># print(next(g))</span>g.send(<span class="literal">None</span>)n1 = g.send(<span class="number">5</span>)n2 = g.send(<span class="number">5</span>)<span class="built_in">print</span>(n1)<span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/10/31 16:48</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : generator04.py</span><span class="comment"># @Software : PyCharm</span><span class="comment"># 进程&gt;线程&gt;协程</span><span class="comment"># 迅雷：</span><span class="keyword">def</span> <span class="title function_">task1</span>(<span class="params">n</span>):    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):        <span class="built_in">print</span>(<span class="string">&#x27;正在搬第&#123;&#125;块砖&#x27;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>))        <span class="keyword">yield</span> <span class="literal">None</span><span class="keyword">def</span> <span class="title function_">task2</span>(<span class="params">i</span>):    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i):        <span class="built_in">print</span>(<span class="string">&#x27;正在听第&#123;&#125;首歌&#x27;</span>.<span class="built_in">format</span>(i + <span class="number">1</span>))        <span class="keyword">yield</span> <span class="literal">None</span>g1 = task1(<span class="number">5</span>)g2 = task2(<span class="number">5</span>)<span class="keyword">while</span> <span class="literal">True</span>:    <span class="comment"># next(g1)</span>    <span class="comment"># next(g2)</span>    <span class="keyword">try</span>:        g1.__next__()        g2.__next__()    <span class="keyword">except</span>:        <span class="keyword">break</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">生成器：generator</span><span class="string"></span><span class="string">定义生成器方式：</span><span class="string">1.通过列表推导式的方式</span><span class="string">    g = (x+1 for x in rang(6))</span><span class="string">2.复杂+yield</span><span class="string">    def func():</span><span class="string">        ...</span><span class="string">        yield</span><span class="string">    </span><span class="string">    g = func()</span><span class="string"></span><span class="string">产生元素：</span><span class="string">    1.next(generator)  ----》每次调用都会产生一个新的元素，如果元素产生完毕，再次调用的话就会产生异常</span><span class="string">    2.生成器自己的方法：</span><span class="string">        g.__next__()</span><span class="string">        g.send(value)</span><span class="string"></span><span class="string">    应用：协程</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/10/31 0:28</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : list01.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment"># 列表推导式</span><span class="comment"># 旧的列表-----》新的列表</span><span class="comment"># 1、列表推导式： 格式：[表达式 for 变量 in 旧列表] 或者 [表达式 for 变量 in 旧列表 if 条件]</span><span class="comment"># 过滤掉长度小于或者等于3的人名</span>names = [<span class="string">&#x27;tome&#x27;</span>, <span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;steven&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]result = [name.capitalize() <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name) &gt; <span class="number">3</span>]<span class="built_in">print</span>(result)<span class="comment"># 将1-100之间能被3整除，组成一个新列表</span>nwelist = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>) <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span> <span class="keyword">and</span> i % <span class="number">5</span> == <span class="number">0</span>]<span class="built_in">print</span>(nwelist)<span class="comment"># [(偶数,奇数),(),(),()] [(0,1),(0,3),(0,5)]</span>nwelist1 = [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>) <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> j % <span class="number">2</span> != <span class="number">0</span>]<span class="built_in">print</span>(nwelist1)<span class="comment"># list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [1, 3, 5]] ----&gt;[3 ,6 , 9, 5]</span>list1 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]]nwelist2 = [i[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> list1]<span class="built_in">print</span>(nwelist2)dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;salart&#x27;</span>: <span class="number">5000</span>&#125;dict2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;salart&#x27;</span>: <span class="number">8000</span>&#125;dict3 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;salart&#x27;</span>: <span class="number">4500</span>&#125;dict4 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lily&#x27;</span>, <span class="string">&#x27;salart&#x27;</span>: <span class="number">3000</span>&#125;list1 = [dict1, dict2, dict3, dict4]<span class="comment"># 如果薪资大于5000加200，低于等于5000加500</span>nwelist1 = [employee[<span class="string">&#x27;salart&#x27;</span>] + <span class="number">300</span> <span class="keyword">if</span> employee[<span class="string">&#x27;salart&#x27;</span>] &gt; <span class="number">5000</span> <span class="keyword">else</span> employee[<span class="string">&#x27;salart&#x27;</span>] + <span class="number">500</span> <span class="keyword">for</span> employee <span class="keyword">in</span> list1]<span class="built_in">print</span>(nwelist1)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">def func(names)</span><span class="string">    newlist=[]</span><span class="string">    for name in names:</span><span class="string">        if len(name)&gt;3:</span><span class="string">            newlist.append(name)</span><span class="string">        return newlist</span><span class="string"></span><span class="string">print(func())</span><span class="string">def func()</span><span class="string">    newlist = []</span><span class="string">    for i in range(5):  # 偶数</span><span class="string">        if i % 2 == 0：</span><span class="string">            for j in range(10):</span><span class="string">                if j % 2 != 0:</span><span class="string">                    newlist.append((i,j))</span><span class="string">print(func())</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># 集合推导式</span>list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>]set1 = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> list1 <span class="keyword">if</span> x &gt; <span class="number">5</span>&#125;<span class="built_in">print</span>(set1)<span class="comment"># 字典推导式</span>dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;D&#x27;</span>&#125;newdict = &#123;value: key <span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items()&#125;<span class="built_in">print</span>(newdict)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows装mysql解压版教程</title>
      <link href="/posts/5880561a.html"/>
      <url>/posts/5880561a.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><p>用<strong>管理员</strong>打开CMD，切换到MySql的解压目录下的<code>bin</code>目录：</p></li><li><p>执行以下命令</p></li></ul><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">执行这里会生成，记住这个密码</span>mysqld --initialize --console<span class="meta prompt_"># </span><span class="language-bash">安装mysql服务</span>mysqld -install<span class="meta prompt_"># </span><span class="language-bash">windows</span>mysqld.exe --initialize --consolemysqld.exe -install</code></pre><ul><li><p>输入命令<code>net start mysql</code>或<code>sc start mysql</code>启动mysql服务</p></li><li><p>输入<code>mysql -u root -p</code>来登陆数据库，并输入前面记录的临时密码：</p></li><li><p>登陆成功后输入以下命令<code>a</code>将原来复杂的密码修改为自己的密码，并输入<code>commit;</code>提交：</p></li></ul> <pre><code class="highlight mysql">/*1、修改密码*/alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;想要设置的密码&#x27;;/*2、由于mysql 8.0*修改加密方式，使用下面命令可以解决大部分无法连接数据库命令*/ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;1&#x27; PASSWORD EXPIRE NEVER;/*3、MySQL8.0的caching_sha2_password问题*/ALTER USER root@localhost IDENTIFIED WITH mysql_native_password BY &#x27;1&#x27;;FLUSH PRIVILEGES;</code></pre><ul><li>在mysql的目录下设置配置文件my.ini</li></ul><pre><code class="highlight mysql">[mysqld] # 设置mysql的安装目录，也就是刚才我们解压的目录basedir=D:/Program Files/mysql/mysql-8.0.27-winx64# 设置mysql数据库的数据的存放目录# datadir=D:/Program Files/mysql/mysql-8.0.27-winx64/data# 设置默认使用的端口port=3306# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人试图攻击数据库max_connect_errors=10# 服务端使用的字符集character-set-server=utf8mb4# 数据库字符集对应一些排序等规则使用的字符集collation-server=utf8mb4_general_ci# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件作为认证加密方式# MySQL8.0默认认证加密方式为caching_sha2_passworddefault_authentication_plugin=mysql_native_password [mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4 [client]default-character-set=utf8mb4port=3306</code></pre><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><pre><code class="highlight mysql">/*删除mysql*/taskkill /f /t /im mysqld.exesc delete mysql/*停止MySQL服务*/net stop mysqld 或者 sc stop mysqld/*删除MySQL服务*/sc delete mysqld 或 mysqld -remove（需先停止服务）</code></pre>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows远程桌面docker容器</title>
      <link href="/posts/354df3ef.html"/>
      <url>/posts/354df3ef.html</url>
      
        <content type="html"><![CDATA[<p>编写Dockerfile文件（可选择dokcer文件，我没测试）</p><p>（Windows无法连通docker容器所以这是Linux中做的实验）</p><pre><code class="highlight shell">FROM centosMAINTAINER Wans&lt;wa.ns@qq.com&gt;ENV MYPATH /sbin/initWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsRUN rpm -Uvh https://mirrors.tuna.tsinghua.edu.cn/epel/epel-release-latest-7.noarch.rpmRUN yum -y install xrdpRUN systemctl start xrdpRUN systemctl enable xrdpCMD echo $MYPATHCMD echo &quot;----end----&quot;</code></pre><p>1、放行3389端口，重启防火墙</p><pre><code class="highlight shel">firewall-cmd --permanent --zone=public --add-port=3389/tcpfirewall-cmd --reload</code></pre><p>2、运行docker centos容器</p><pre><code class="highlight shell">docker run -it -p 3389:3389 -p 3350:3350 --privileged true --name mycentos centos /sbin/init</code></pre><p>3、安装xrdp、vim、net-tools</p><pre><code class="highlight shell">yum -y install vimyum -y install net-toolsrpm -Uvh https://mirrors.tuna.tsinghua.edu.cn/epel/epel-release-latest-7.noarch.rpmyum -y install xrdp</code></pre><p>启动xrdp</p><pre><code class="highlight shell">systemctl start xrdpsystemctl enable xrdp</code></pre><p>打开Windows远程连接就好</p><p><img src="/posts/354df3ef/image-20211010160758852.webp" alt="image-20211010160758852"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker自学</title>
      <link href="/posts/34285.html"/>
      <url>/posts/34285.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker安装（linux）"><a href="#Docker安装（linux）" class="headerlink" title="Docker安装（linux）"></a>Docker安装（linux）</h1><p>安装docker</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">卸载干净</span><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> yum remove docker \</span><span class="language-bash">                  docker-client \</span><span class="language-bash">                  docker-client-latest \</span><span class="language-bash">                  docker-common \</span><span class="language-bash">                  docker-latest \</span><span class="language-bash">                  docker-latest-logrotate \</span><span class="language-bash">                  docker-logrotate \</span><span class="language-bash">                  docker-engine</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">安装包</span>yum install -y yum-utils<span class="meta prompt_"># </span><span class="language-bash">设置镜像仓库</span>yum-config-manager \    --add-repo \    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="meta prompt_"># </span><span class="language-bash">更新yum软件包索引</span>yum makecache fast<span class="meta prompt_"># </span><span class="language-bash">安装docker相关的包</span>yum install docker-ce docker-ce-cli containerd.io<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动docker</span>systemctl start docker<span class="meta prompt_"># </span><span class="language-bash">运行docker容器</span>docker run hello-world</code></pre><h2 id="Docker卸载（linux）"><a href="#Docker卸载（linux）" class="headerlink" title="Docker卸载（linux）"></a>Docker卸载（linux）</h2><pre><code class="highlight shell">1、卸载依赖yum remove docker-ce docker-ce-cli containerd.io2、删除资源rm -rf /var/lib/docker</code></pre><h2 id="配置Docker加速"><a href="#配置Docker加速" class="headerlink" title="配置Docker加速"></a>配置Docker加速</h2><pre><code class="highlight shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;    &quot;registry-mirrors&quot;:[&quot;https://阿里云节点&quot;]   &#125;</code></pre><h2 id="修改Docker默认镜像储存位置"><a href="#修改Docker默认镜像储存位置" class="headerlink" title="修改Docker默认镜像储存位置"></a>修改Docker默认镜像储存位置</h2><p><strong>暂停docker</strong></p><pre><code class="highlight shell">wsl --shutdown</code></pre><p><strong>导出原有镜像</strong></p><pre><code class="highlight shell">wsl --export docker-desktop &quot;D:\Docker\wsl\data\docker-desktop.tar&quot;wsl --export docker-desktop-data &quot;D:\Docker\wsl\data\docker-desktop-data.tar&quot;</code></pre><p><strong>取消原有镜像</strong></p><pre><code class="highlight shell">wsl --unregister docker-desktopwsl --unregister docker-desktop-data</code></pre><p><strong>导入镜像</strong></p><pre><code class="highlight shell">wsl --import docker-desktop D:\Docker\wsl\distro D:\Docker\wsl\data\docker-desktop.tar --version 2wsl --import docker-desktop-data D:\Docker\wsl\data D:\Docker\wsl\data\docker-desktop-data.tar --version 2</code></pre><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><pre><code class="highlight shell">docker version          # 显示docker的版本docker info             # 显示docker系统级信息，包括镜像和容器的数量docker 命令 --help       # 帮助命令</code></pre><h2 id="帮助文档（中文）"><a href="#帮助文档（中文）" class="headerlink" title="帮助文档（中文）"></a><a href="http://www.dockerinfo.net/document">帮助文档（中文）</a></h2><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><pre><code class="highlight shell">docker images           # 查看镜像-a                      # 显示所有的镜像-q                      # 只显示容器的iddocker search           # 搜索镜像--fileter=STARS=3000    # 搜索出来的镜像就是stars大于3000的docker pull             # 下载镜像docker pull mysql:5.7</code></pre><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><pre><code class="highlight shell">docker rmi -f images iddocker rmi -f $(docker images -aq)       # 删除所有的images</code></pre><h2 id="运行容器命令"><a href="#运行容器命令" class="headerlink" title="运行容器命令"></a>运行容器命令</h2><pre><code class="highlight shell">docker run [可选参数] image参数说明--name=“name” # 容器命令-d            # 后台运行-it           # 使用交互方式运行，进入容器查看内容-p            # 指定容器的端口 -p 80:80        -p ip:主机端口：容器端口        -p 主机端口容器端口（常用）        -p 容器端口        -P(大写)  # 随机指定端口docker run -itd -p 80:80 [imgaes]</code></pre><h2 id="列出所有的运行容器"><a href="#列出所有的运行容器" class="headerlink" title="列出所有的运行容器"></a>列出所有的运行容器</h2><pre><code class="highlight shell">docker ps-a      # 显示所有的容器+历史运行的容器-n=？   # 列出最近创建的容器-q      # 只显示容器的编号</code></pre><h2 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h2><pre><code class="highlight shell">exit        # 退出并通知容器Ctrl+p+q    # 容器不停止退出</code></pre><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><pre><code class="highlight shell">docker rmi -f 镜像id                # 删除指定镜像docker rmi -f 镜像id 镜像id 镜像id   # 删除多个镜像 docker rmi -f $(docker images aq)   # 删除全部镜像docker rm -f 容器id                 # 删除指定容器docker rm -f 容器 容器 镜像id        # 删除多个容器 docker rm -f $(docker ps -aq)       # 删除全部容器docker ps -a -q|xargs docker rm     # 删除全部容器</code></pre><h2 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h2><pre><code class="highlight shell">docker startdocker restartdocker stopdocker kill</code></pre><h2 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h2><pre><code class="highlight shell">后台启动容器docker run -d 镜像问题 docker ps 发现容器停止docker容器使用后台运行，就必须有应该前台进程，docker发现没有应用就会停止</code></pre><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><pre><code class="highlight shell">docker log -f -t --tail 容器，没有日志</code></pre><h2 id="查看容器的信息"><a href="#查看容器的信息" class="headerlink" title="查看容器的信息"></a>查看容器的信息</h2><pre><code class="highlight shell">docker inspect 容器<span class="meta prompt_"># </span><span class="language-bash">将本地的镜像导出</span>docker save -o 导出的路径 镜像id<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">加载本地的镜像文件</span>docker load -i 镜像文件<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">修改镜像文件</span>docker tag 镜像id 新镜像名称：版本<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">保存当前容器的状态</span>docker commit  [CONTAINER ID] demo：v1.3</code></pre><h2 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h2><pre><code class="highlight shell">方法1docker exec -it 容器id /bin/bash方法2docker attach  容器id 区别：exec命令，进入容器后开启一个新的终端，可以操作（常用）attach命令，进入容器正在执行的终端，不会启动新的进程</code></pre><h2 id="从容器拷贝文件到主机上"><a href="#从容器拷贝文件到主机上" class="headerlink" title="从容器拷贝文件到主机上"></a>从容器拷贝文件到主机上</h2><pre><code class="highlight shell">docker cp 容器:容器内的路径 主机的路径同理的主机到容器</code></pre><h2 id="部署es-kubana"><a href="#部署es-kubana" class="headerlink" title="部署es+kubana"></a>部署es+kubana</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">es暴露的端口多，耗内存，数据放安全目录，挂载</span><span class="meta prompt_"># </span><span class="language-bash">--net somenetwork   网络配置</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动elasticsearch</span>docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">如果是云服务 linux就卡住</span><span class="meta prompt_"># </span><span class="language-bash">docker stats 查看cpu状态</span><span class="meta prompt_"># </span><span class="language-bash">es 耗内存</span><span class="meta prompt_"># </span><span class="language-bash">测试es是否成功</span><span class="meta prompt_"># </span><span class="language-bash">访问 http://127.0.0.1:9200</span>&#123;  &quot;name&quot; : &quot;1043572a13e5&quot;,  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,  &quot;cluster_uuid&quot; : &quot;X5qHk_JRRhK9HPKWfaMvYg&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.6.2&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;docker&quot;,    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.4.0&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</code></pre><pre><code class="highlight shel"># 增加内存的限制，修改配置文件 -e 环境配置修改docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2</code></pre><p>作业：使用kibana连接ES</p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><ul><li>portainer(先用这个)</li></ul><pre><code class="highlight shell">docker run -d -p 8088:9000 \ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre><ul><li>Rancher(CI&#x2F;CD再用)</li></ul><p><strong>什么是portainer？</strong></p><pre><code class="highlight shell">docker run -d -p 8088:9000 \ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre><p>docker图形化管理工具！提供一个后台面板供我们操作！</p><h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含<br>运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><p>所有应用，直接打包docker镜像，就可以直接跑起来！</p><ul><li><p>从远程仓库下载</p></li><li><p>朋友拷贝给你</p></li><li><p>自己制作镜像Dockerfile</p></li></ul><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote><p>UnionFS(联合文件系统)</p></blockquote><p>我们下载的时候看到的一层层就是这个</p><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，<br>它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系<br>统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基<br>础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。<br>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件<br>系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p><blockquote><p>Docker镜像加载原理  </p></blockquote><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启<br>动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是<br>一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已<br>由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标<br>准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。.</p><p>如何提交一个自己的镜像</p><h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><pre><code class="highlight shell">docker commit 提交容器成为一个新容器docker commit -m=&quot;提交描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[tag]</code></pre><p>实战测试</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">1、启动一个默认的tomcat</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">2、发现这个tomcat没有webapps应用,官方镜像webapps没有文件!</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">3、自己拷贝进去基本的文件</span><span class="meta prompt_"># </span><span class="language-bash">4、将我们操作过的容器通过commit提交为一个镜像,我们以后就是用我们修改过的镜像</span></code></pre><p><img src="/posts/34285/image-20211006180546891.webp" alt="image-20211006180546891"></p><p>学习方式说明：理解概念，但是一定要实践</p><pre><code class="highlight shell">如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像相当于快照</code></pre><p>到这里才是入门！！！学习不需要坚持，学习是爱好！！！</p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><blockquote><p>docker的理念和回顾</p></blockquote><p>将应用和环境打包成一个镜像！</p><p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失&#x3D;&#x3D;需求：数据可以持久化&#x3D;&#x3D;</p><p>MySQL，容器删除，删库跑路！&#x3D;&#x3D;需求：MySQL数据可以储存在本地&#x3D;&#x3D;！</p><p>容器之间可以有一个共享的技术！Docker容器中产生的数据，同步到本地！</p><p>这就是卷技术！目录的挂载，将我们的容器内的目录，挂在到Linux什么！</p><p><img src="/posts/34285/image-20211006195711247.webp" alt="image-20211006195711247"></p><p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote><p>方式一：直接使用命令来挂载</p></blockquote><pre><code class="highlight shell">docker run -it -v 主机目录:容器目录<span class="meta prompt_"># </span><span class="language-bash">测试</span>docker run -it -v D:/dockertest/tomcat:/home tomcat /bin/bash</code></pre><p>这里可以看到成功挂载了</p><p><img src="/posts/34285/image-20211006201204091.webp" alt="挂载成功"></p><p>测试同步</p><p><img src="/posts/34285/image-20211006201602762.webp" alt="image-20211006201602762"></p><p>再来测试！</p><p>1、停止容器</p><p>2、宿主机上修改文件</p><p>3、启动容器</p><p>4、容器内的数据依旧是同步的！</p><p><img src="/posts/34285/image-20211006202110667.webp" alt="image-20211006202110667"></p><p>好处：我们以后修改只需要在本地修改即可，容器内会自动同步</p><h2 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h2><p>思考：mysql的数据持久化</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">获取镜像</span>docker pull mysql:5.7<span class="meta prompt_"># </span><span class="language-bash">运行容器，需要做数据挂载！</span><span class="meta prompt_"># </span><span class="language-bash">安装MySQL，需要配置密码的，</span><span class="meta prompt_"># </span><span class="language-bash">官方测试：docker run -name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动我们的mysql</span>-d 后台运行-p 端口映射-v 卷挂载-e 环境配置--name 容器名字docker run -d -p 3310:3306 -v D:/dockertest/mysql/conf:/etc/mysql/conf.d -v D:/dockertest/mysqldata:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7启动成功</code></pre><p>假设我们将容器删除</p><p><img src="/posts/34285/image-20211006204840217.webp" alt="image-20211006204840217"></p><p>发现我们挂载到本地的数据卷依旧没有丢失，这就实现了容器数据的持久性功能</p><h2 id="具名和匿名挂载"><a href="#具名和匿名挂载" class="headerlink" title="具名和匿名挂载"></a>具名和匿名挂载</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载(直接写容器捏路径，不去写主机内路径，可以自动生成主机路径)</span>-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看volume情况</span>PS C:\Users\Wans&gt; docker volume lsDRIVER    VOLUME NAMElocal     2de53d078ecf017bc509e723f27f6b561f665c0cccf7946d62882e89493ce68a<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">这里发现，这种没有名字就是匿名挂载，我们在-v只写了容器内的路径，没写容器外的路径</span><span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span>PS C:\Users\Wans&gt; docker run -d -P --name nginx02 -v jvming:/etc/nginx nginx4e3ecbe8f7ab5c25b2a00cb882f0c744bb5c849070c7a7772fb304e7a1a4df2cPS C:\Users\Wans&gt; docker volume lsDRIVER    VOLUME NAMElocal     jvmingPS C:\Users\Wans&gt;<span class="meta prompt_"># </span><span class="language-bash">通过-v 卷名：容器内路径</span><span class="meta prompt_"># </span><span class="language-bash">查看一下这个卷</span></code></pre><p><img src="/posts/34285/image-20211006210349955.webp" alt="image-20211006210349955"><br>所有的docker容器内的卷，没有指定目录的情况下都在<code>/var/lib/docker/volumes/xxx/_data</code></p><p>我们通过具名挂载可以方便的找到我们的一个卷，大多数情况在使用的<code>具名挂载</code></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载！</span>-v 容器内路径#匿名挂载-v 卷名：容器内路径#具名挂载-v /宿主机路径:容器内路径# 指定路径挂载！</code></pre><p>拓展</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">通过-v容器内路径: ro rw 改变读写权限</span>ro readonly # 只读rw readwrite # 可读可写<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">一旦这个设置了容器权限，容器对我们挂载出来的内容就有限了</span>docker run -d -P --name nginx02 -v jvming:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v jvming:/etc/nginx:rw nginx<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">ro只要看到ro说明这个路径只能通过宿主机来操作，容器内部无法操作</span></code></pre><h2 id="初始Dockerfile"><a href="#初始Dockerfile" class="headerlink" title="初始Dockerfile"></a>初始Dockerfile</h2><p>Dockerfile就是用来构建dockers镜像的构建文件！命令脚本、先体验一下！</p><pre><code class="highlight dockerfile"><span class="comment"># 创建Dockerfile文件，名字可以随意，建议dockerfile</span><span class="keyword">FROM</span> centos<span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;----end----&quot;</span></span><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></code></pre><p><img src="/posts/34285/image-20211006221917614.webp" alt="image-20211006221917614"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">启动自己写的容器</span></code></pre><p><img src="/posts/34285/image-20211006222316149.webp" alt="image-20211006222316149"></p><p>这个卷和外部一定是同步的</p><p>测试一下刚才的文件是否同步出去了！</p><p>这种方式我们未来使用的十分多，因为我们通常会构建自己的镜像！</p><p>假设构建镜像时候没有挂载卷，要手动镜像挂载-v卷名:容器内路径！</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>多个mysql同步数据！</p><p><img src="/posts/34285/image-20211006223333496.webp" alt="image-20211006223333496"></p><pre><code class="highlight plaintext"># 启动3个容器，通过我们刚才自己的写镜像启动</code></pre><p><img src="/posts/34285/image-20211006224547475.webp" alt="image-20211006224547475"></p><p><img src="/posts/34285/image-20211006224352364.webp" alt="image-20211006224352364"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">测试，删除docker01，查看docker02和docker03依旧可以访问volume</span></code></pre><p><img src="/posts/34285/image-20211006225002861.webp" alt="image-20211006225002861"></p><p>多个mysql实现数据共享</p><pre><code class="highlight shell">docker run -d -p 3310:3306 -v /etc/mysql/conf.d -v /var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volome-from mysql01 mysql:5.7<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">这时候可以实现两个容器数据同步</span></code></pre><p>结论：</p><p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止！！</p><p>但是一旦你持久化到本地这个时候，本地的数据不会删除</p><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="Dockerfile介绍"><a href="#Dockerfile介绍" class="headerlink" title="Dockerfile介绍"></a>Dockerfile介绍</h2><p>dockerfile是用来构建docker镜像的文件！命令参数脚本！</p><p>构建步骤：</p><p>1、编写dockerfile文件</p><p>2、docker build 构建成为一个镜像</p><p>3、docker run 运行镜像</p><p>4、docker push 发布镜像（dockerhub、阿里云镜像仓库）</p><p><img src="/posts/34285/image-20211007061934942.webp" alt="image-20211007061934942"></p><p><img src="/posts/34285/image-20211007062001424.webp" alt="image-20211007062001424"></p><p>很多官方镜像都是基础包好的功能没有，我们提出会搭建自己的镜像</p><h2 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h2><p><strong>基础知识</strong></p><p>1、每个保留关键字（指令）都是必须是大写字母</p><p>2、执行是从上到下顺序执行</p><p>3、# 表示注释</p><p>4、每个指令都会创建提交一个新的镜像层，并提交</p><p><img src="/posts/34285/image-20211007062549193.webp" alt="image-20211007062549193"></p><p>步骤：开发、部署、运维、缺一不可</p><p>dockerfile：构建文件，定义一切的步骤，源代码</p><p>dockerimages：通过dockerfile构建生成的镜像，最终发布和运行的产品</p><p>docker容器：容器就是镜像运行起来提供服务器</p><h2 id="Dockerfile的指令"><a href="#Dockerfile的指令" class="headerlink" title="Dockerfile的指令"></a>Dockerfile的指令</h2><pre><code class="highlight shell">FROM# 基础镜像，一切从这里开始构建MAINTAINER# 镜像构建者信息：姓名+邮箱RUN# 镜像构建的时候要运行的命令ADD# 步骤：tomecat镜像，这个tomcat压缩包！添加内容WORKDIR# 镜像的工作目录VOLUME# 挂载的目录EXPOST# 保留端口配置CMD# 指定这个容器启动的时候要运行的命令,只有最后一个会生效，可被替代ENTRYPOINT# 指定这个容器启动的时候要运行的命令ONBUILD# 当构建一个被继承Dockerfile这个时候就会运行ONBUILD的指令，出发指令COPY# 类似ADD，将我们文件拷贝到镜像中ENV# 构建的时候设置环境变量 -e</code></pre><p><img src="/posts/34285/image-20211007064730968.webp" alt="image-20211007064730968"></p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2><p>Docker hub 中99%都是从FROM scratch，然后配置需要的软件和配置来进行的构建</p><blockquote><p>创建自己的centos镜像</p></blockquote><pre><code class="highlight dockerfile"><span class="comment"># 1、编写Dockerfiel文件</span><span class="comment"># FROM centos</span><span class="comment"># VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><span class="comment"># CMD echo &quot;----end----&quot;</span><span class="comment"># CMD /bin/bash</span><span class="keyword">FROM</span> centos<span class="keyword">MAINTAINER</span> Wans&lt;wa.ns@qq.com&gt;<span class="comment"># 环境变量</span><span class="keyword">ENV</span> MYPATH /usr/local<span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span><span class="keyword">RUN</span><span class="language-bash"> yum -y install net-tools</span><span class="keyword">EXPOSE</span> <span class="number">80</span><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;----end----&quot;</span></span><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span><span class="comment"># 2、通过这个文件构建镜像</span><span class="comment"># 命令 docker build -f &lt;dockerfile文件路径&gt; -t 镜像名:[tag]</span><span class="comment"># 3、测试运行，添加了vim和ifconfig</span></code></pre><p><img src="/posts/34285/image-20211007074651332.webp" alt="image-20211007074651332"></p><p>我们可以看看镜像的历史记录，就可以永久它是怎么做的</p><p><img src="/posts/34285/image-20211007075255351.webp" alt="image-20211007075255351"></p><blockquote><p>CMD和ENTRYPOINT区别</p></blockquote><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">编写dokcerfile文件</span>FROM centosCMD [&quot;ls&quot;,&quot;-a&quot;]<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">构建镜像</span>PS D:\dockertest&gt; docker build -f Dockerfile -t cmdtest:0.1 .[+] Building 22.3s (5/5) FINISHED =&gt; [internal] load build definition from Dockerfile                                                                              2.5s =&gt; =&gt; transferring dockerfile: 381B                                                                                              0.0s =&gt; [internal] load .dockerignore                                                                                                 3.8s =&gt; =&gt; transferring context: 2B                                                                                                   0.0s =&gt; [internal] load metadata for docker.io/library/centos:latest                                                                 16.4s =&gt; CACHED [1/1] FROM docker.io/library/centos@sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177            0.0s =&gt; exporting to image                                                                                                            0.7s =&gt; =&gt; exporting layers                                                                                                           0.0s =&gt; =&gt; writing image sha256:7d202bdf002be182b794b7f2b4c90c4fe3560c3ac4f8cebc27f1c8a94ab10a9a                                      0.3s =&gt; =&gt; naming to docker.io/library/cmdtest:0.1                                                                                    0.4sUse &#x27;docker scan&#x27; to run Snyk tests against images to find vulnerabilities and learn how to fix them<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">run运行，发现<span class="built_in">ls</span> -a命令生效</span>PS D:\dockertest&gt; docker run cmdtest:0.1....dockerenvbindevetchomeliblib64lost+foundmediamntoptprocrootrunsbinsrvsystmpusrvar<span class="meta prompt_"># </span><span class="language-bash">无法追加-l命令</span>PS D:\dockertest&gt; docker run cmdtest:0.1 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.<span class="meta prompt_">#</span><span class="language-bash">cmd的情况下 -l 替换 CMD [<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-a&quot;</span>]命令，-l不是命令所以报错！</span><span class="meta prompt_"># </span><span class="language-bash">使用ENTRYPOINT 则可以在run后面加-l</span></code></pre><p>Dockerfile中很多命令都十分相似，我们需要了解他们的区别。</p><h2 id="实战：Tomcat镜像"><a href="#实战：Tomcat镜像" class="headerlink" title="实战：Tomcat镜像"></a>实战：Tomcat镜像</h2><h3 id="1、准备镜像文件tomcat压缩包，jdk的压缩包"><a href="#1、准备镜像文件tomcat压缩包，jdk的压缩包" class="headerlink" title="1、准备镜像文件tomcat压缩包，jdk的压缩包"></a>1、准备镜像文件tomcat压缩包，jdk的压缩包</h3><p><img src="/posts/34285/image-20211007115140033.webp" alt="image-20211007115140033"></p><h3 id="2、-编写dockerfile文件，"><a href="#2、-编写dockerfile文件，" class="headerlink" title="2、 编写dockerfile文件，"></a>2、 编写dockerfile文件，</h3><p> 官方命名<code>Dockerfile</code>,build会自动寻找这个文件，就不需要-f指定了</p><pre><code class="highlight dockerfile"><span class="comment"># vim Dockerfile</span><span class="keyword">FROM</span> centos<span class="keyword">MAINTAINER</span> Wans&lt;wa.ns@qq.com&gt;<span class="comment"># 把宿主机当前上下文的read.txt拷贝到容器/usr/local/路径下</span><span class="keyword">COPY</span><span class="language-bash"> Readme.md /usr/local/Readme.md</span><span class="comment"># 把java与tomcat添加到容器中</span><span class="keyword">ADD</span><span class="language-bash"> jdk-8u11-linux-x64.tar.gz /usr/local/</span><span class="keyword">ADD</span><span class="language-bash"> apache-tomcat-9.0.54.tar.gz /usr/local/</span><span class="comment"># 安装vim编辑器</span><span class="keyword">RUN</span><span class="language-bash"> yum -y install vim</span><span class="comment"># 设置工作访问时候的WORKDIR路径，登录落脚点</span><span class="keyword">ENV</span> MYPATH /usr/local<span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$MYPATH</span></span><span class="comment"># 配置java与tomcat环境变量</span><span class="keyword">ENV</span> JAVA_HOME /usr/local/jdk-<span class="number">8</span>u11-linux-x64<span class="keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<span class="keyword">ENV</span>CATALINA_HOME /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">54</span><span class="keyword">ENV</span>CATALINA_BASH /usr/local/apache-tomcat-<span class="number">9.0</span>.<span class="number">54</span><span class="keyword">ENV</span>PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin<span class="keyword">EXPOSE</span> <span class="number">8080</span><span class="keyword">CMD</span><span class="language-bash"> /usr/local/apache-tomcat-9.0.54/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /url/local/apache-tomcat-9.0.54/bin/logs/catalina.out</span></code></pre><h3 id="3、构建镜像"><a href="#3、构建镜像" class="headerlink" title="3、构建镜像"></a>3、构建镜像</h3><pre><code class="highlight shell">docker build -t wanstomcat .</code></pre><p>4、启动镜像</p><pre><code class="highlight shell">docker run -d -p 9090:8080 --name wanstomcat -v D:/dockertest/tomcat/test:/usr/local/apache-tomcat-9.0.54/webapps/test -v  D:/dockertest/tomcat/logs/:/url/local/apache-tomcat-9.0.54/logs wanstomcat</code></pre><p>5、 访问测试</p><p><img src="/posts/34285/image-20211008062543095.webp" alt="image-20211008062543095"></p><p>6、发布项目（由于做了卷挂载，我们直接本地编写项目就可以发布了）</p><h1 id="Dockers网络"><a href="#Dockers网络" class="headerlink" title="Dockers网络"></a>Dockers网络</h1><h2 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h2><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">问题Docker怎么处理容器网络访问的？</span></code></pre><p><img src="/posts/34285/image-20211008204301074.webp" alt="image-20211008204301074"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">docker run -d -P --name tomcat01 tomcat</span><span class="meta prompt_"></span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看容器的内部网络地址 ip addr 因为我下载的tomcat 没有ip addr 命令</span><span class="meta prompt_"># </span><span class="language-bash">所以我就使用了<span class="built_in">ls</span> -la测试了一下</span>docker exec -it tomcat01 ls -laPS C:\Users\Wans&gt; docker exec -it 7c2708f0dd7a ls -latotal 176drwxr-xr-x 1 root root  4096 Oct  6 19:10 .drwxr-xr-x 1 root root  4096 Sep 29 11:13 ..-rw-r--r-- 1 root root 18994 Sep 28 13:34 BUILDING.txt-rw-r--r-- 1 root root  6210 Sep 28 13:34 CONTRIBUTING.md-rw-r--r-- 1 root root 60269 Sep 28 13:34 LICENSE-rw-r--r-- 1 root root  2333 Sep 28 13:34 NOTICE-rw-r--r-- 1 root root  3372 Sep 28 13:34 README.md-rw-r--r-- 1 root root  6905 Sep 28 13:34 RELEASE-NOTES-rw-r--r-- 1 root root 16517 Sep 28 13:34 RUNNING.txtdrwxr-xr-x 2 root root  4096 Oct  6 19:10 bindrwxr-xr-x 1 root root  4096 Oct  8 13:05 confdrwxr-xr-x 2 root root  4096 Oct  6 19:10 libdrwxrwxrwx 1 root root  4096 Oct  8 13:05 logsdrwxr-xr-x 2 root root  4096 Oct  6 19:10 native-jni-libdrwxrwxrwx 2 root root  4096 Oct  6 19:10 tempdrwxr-xr-x 2 root root  4096 Oct  6 19:10 webappsdrwxr-xr-x 7 root root  4096 Sep 28 13:34 webapps.distdrwxrwxrwx 2 root root  4096 Sep 28 13:34 workPS C:\Users\Wans&gt;<span class="meta prompt_"># </span><span class="language-bash">linux 可以 ping 通 docker 容器内部</span></code></pre><blockquote><p>原理 </p></blockquote><p>1、我们没安装一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker就会有一个网卡Docker0桥接模式，使用的技术是evth-pair技术！</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">evth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一段连着协议，一段彼此相连</span><span class="meta prompt_"># </span><span class="language-bash">evth-pair充当桥梁，连接各种虚拟网络设备的</span><span class="meta prompt_"># </span><span class="language-bash">openStac，docker容器之间的连接，ovs的连接，都是evth-pair技术</span></code></pre><p>2、tomcat01和tomcat02直接可以ping通</p><p><img src="/posts/34285/image-20211008223737900.webp" alt="image-20211008223737900"></p><p>结论：tomcat01和tomcat02是共用一个路由器，docker0</p><p>所有的容器不指定网络的情况下，都是docker0路由器的，docker会给我们的容器分配一个默认的可用ip</p><blockquote><p>小结</p></blockquote><p>Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0</p><p><img src="/posts/34285/image-20211008224414385.webp" alt="image-20211008224414385"></p><p>Docker中的所有的网络接口都是虚拟的，虚拟转发效率高</p><p>只要容器删除，对应的一对网桥就删除</p><h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><blockquote><p>思考一个场景，我们就编写了一个微服务，database url &#x3D; ip，项目部重启，数据库ip换掉了，我们希望可以处理这个问题，可以用名字来访问容器</p></blockquote><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">不能ping通</span><span class="meta prompt_"># </span><span class="language-bash">PS D:\Users\Wans\Desktop&gt; docker <span class="built_in">exec</span> -it tomcat02 ping tomcat01</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">通过 --<span class="built_in">link</span>可以解决名字ping</span>docker run -d -P --name tomcat03 --link tomcat02 tomcat<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">反向不可以ping通</span>docker exec -it tomcat02 ping tomcat03</code></pre><p><img src="/posts/34285/image-20211008230158994.webp" alt="image-20211008230158994"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">这里看到--<span class="built_in">link</span>将tomcat02的地址写在hosts中</span></code></pre><p>现在已经不推荐–linkl</p><p>自定义网络！！不适合docker0！</p><p>docker0问题：不支持容器名连接访问</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><blockquote><p>查看所有的docker网络</p></blockquote><p><img src="/posts/34285/image-20211008230613841.webp" alt="image-20211008230613841"></p><p><strong>网络模式</strong></p><p>bridge：桥接模式（莫仍，自己创建也使用桥接模式）</p><p>host：主机模式（和宿主机共享网络）</p><p>none：不配网络</p><p>container：容器网络连通（用的少，局限大）</p><p><strong>测试</strong></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">我们直接启动的命令 --net bridge，而这个就是我们的docker0</span>docker run -d -P --name tomcat01 tomcat<span class="meta prompt_"># </span><span class="language-bash">--net bridge（这个是默认的）</span>docker run -d -P --name tomcat01 --net bridge tomcat<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">docker0特点：默认，域名不能访问， --<span class="built_in">link</span>可以打通连接！</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">查看创建网卡的命令</span>PS D:\Users\Wans\Desktop&gt; docker network create --helpUsage:  docker network create [OPTIONS] NETWORKCreate a networkOptions:      --attachable           Enable manual container attachment      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by                             Network driver (default map[])      --config-from string   The network from which to copy the configuration      --config-only          Create a configuration only network  -d, --driver string        Driver to manage the Network (default &quot;bridge&quot;)      --gateway strings      IPv4 or IPv6 Gateway for the master subnet      --ingress              Create swarm routing-mesh network      --internal             Restrict external access to the network      --ip-range strings     Allocate container ip from a sub-range      --ipam-driver string   IP Address Management Driver (default &quot;default&quot;)      --ipam-opt map         Set IPAM driver specific options (default map[])      --ipv6                 Enable IPv6 networking      --label list           Set metadata on a network  -o, --opt map              Set driver specific options (default map[])      --scope string         Control the network&#x27;s scope      --subnet strings       Subnet in CIDR format that represents a                             network segmentPS D:\Users\Wans\Desktop&gt;<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">成功创建网卡</span>PS D:\Users\Wans\Desktop&gt; docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet108130a48496e1f9e2b864cc3fb324dbdd4ccc1822985307773789b7c8ae6e3ePS D:\Users\Wans\Desktop&gt; docker network lsNETWORK ID     NAME      DRIVER    SCOPEe02c3a9814c2   bridge    bridge    localac450d1a3661   host      host      local108130a48496   mynet     bridge    local1e32ceb0b028   none      null      localPS D:\Users\Wans\Desktop&gt;</code></pre><p><img src="/posts/34285/image-20211010212207280.webp" alt="image-20211010212207280"></p><h2 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h2><p><img src="/posts/34285/image-20211010212416674.webp" alt="image-20211010212416674"></p><p><img src="/posts/34285/image-20211010212444973.webp" alt="image-20211010212444973"></p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">测试打通 tomcat -mynet</span><span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">连通之后就是将tomcat01放到了mynet网络下</span><span class="meta prompt_"># </span><span class="language-bash">一个容器两个ip地址 ！</span> <span class="meta prompt_"># </span><span class="language-bash">相当于阿里云服务，内网ip和公网ip</span></code></pre><p><img src="/posts/34285/image-20211010212709223.webp" alt="image-20211010212709223"></p><p>结论：假设要跨网络操作别人，就需要docker network connet连通</p><h2 id="实战：Redis集群"><a href="#实战：Redis集群" class="headerlink" title="实战：Redis集群"></a>实战：Redis集群</h2><p><img src="/posts/34285/image-20211010213235048.webp" alt="image-20211010213235048"></p><p>shell脚本！</p><pre><code class="highlight shell"><span class="meta prompt_"># </span><span class="language-bash">创建网卡</span>docker network create redis --subnet 172.38.0.0/16<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">通过脚本创建六个redis配置</span>for port in $(seq 1 6); \do \mkdir -p /mydata/redis/node-$&#123;port&#125;/conftouch /mydata/redis/node-$&#123;port&#125;/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.1$&#123;port&#125;cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdonedocker run -p 637$&#123;port&#125;:6379 -p 1637$&#123;port&#125;:16379 --name redis-$&#123;port&#125; \-v /mydata/redis/node-$&#123;port&#125;/data:/data \-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.1$&#123;port&#125; redis:5.0.9-alpine3.11 redis-server/etc/redis/redis.conf; \<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">启动6个容器</span>docker run -p 6371:6379 -p 16371:16379 --name redis-1 \-v /mydata/redis/node-1/data:/data \-v /mydata/redis/node-1/conf/redis.conf:/etc/redis/redis.conf \-d --net redis --ip 172.38.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</code></pre><p><img src="/posts/34285/image-20211010220516620.webp" alt="image-20211010220516620"></p><pre><code class="highlight bash"><span class="comment"># 进入redis</span>docker <span class="built_in">exec</span> -it redis-1 /bin/sh<span class="comment"># 创建集群的配置</span>/data <span class="comment"># redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.</span>13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 172.38.0.15:6379 to 172.38.0.11:6379Adding replica 172.38.0.16:6379 to 172.38.0.12:6379Adding replica 172.38.0.14:6379 to 172.38.0.13:6379M: 008bae73c70dc85404d37bd5a2e50803d63c01db 172.38.0.11:6379   slots:[0-5460] (5461 slots) masterM: 08a33c605873c8dc30fd0b883310e09647c22ef8 172.38.0.12:6379   slots:[5461-10922] (5462 slots) masterM: 08da98ed12ca231a64fb18b168df106bcdbc1132 172.38.0.13:6379   slots:[10923-16383] (5461 slots) masterS: 6c466d74c7e2b505c1732280fea7f13177467e2d 172.38.0.14:6379   replicates 08da98ed12ca231a64fb18b168df106bcdbc1132S: e24369c4771b8948325dd5ce2eb4bd99dab415d9 172.38.0.15:6379   replicates 008bae73c70dc85404d37bd5a2e50803d63c01dbS: 32fc9e78674f24cefcc070052f1de39fbf54e4f2 172.38.0.16:6379   replicates 08a33c605873c8dc30fd0b883310e09647c22ef8Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): <span class="built_in">yes</span>&gt;&gt;&gt; Nodes configuration updated&gt;&gt;&gt; Assign a different config epoch to each node&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the clusterWaiting <span class="keyword">for</span> the cluster to <span class="built_in">join</span>...&gt;&gt;&gt; Performing Cluster Check (using node 172.38.0.11:6379)M: 008bae73c70dc85404d37bd5a2e50803d63c01db 172.38.0.11:6379   slots:[0-5460] (5461 slots) master   1 additional replica(s)M: 08a33c605873c8dc30fd0b883310e09647c22ef8 172.38.0.12:6379   slots:[5461-10922] (5462 slots) master   1 additional replica(s)S: 32fc9e78674f24cefcc070052f1de39fbf54e4f2 172.38.0.16:6379   slots: (0 slots) slave   replicates 08a33c605873c8dc30fd0b883310e09647c22ef8S: 6c466d74c7e2b505c1732280fea7f13177467e2d 172.38.0.14:6379   slots: (0 slots) slave   replicates 08da98ed12ca231a64fb18b168df106bcdbc1132S: e24369c4771b8948325dd5ce2eb4bd99dab415d9 172.38.0.15:6379   slots: (0 slots) slave   replicates 008bae73c70dc85404d37bd5a2e50803d63c01dbM: 08da98ed12ca231a64fb18b168df106bcdbc1132 172.38.0.13:6379   slots:[10923-16383] (5461 slots) master   1 additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.</code></pre><p>Docker搭建redis集群完成</p><p><img src="/posts/34285/image-20211010221506757.webp" alt="image-20211010221506757"></p><p>我们使用了docker之后，所有的技术都会简单</p><h1 id="SpringBoot微服务打包Docker镜像"><a href="#SpringBoot微服务打包Docker镜像" class="headerlink" title="SpringBoot微服务打包Docker镜像"></a>SpringBoot微服务打包Docker镜像</h1><p>1、使用 IDEA 构建一个 SpringBoot 项目</p><p>2、编写一个helloController</p><pre><code class="highlight java"><span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;<span class="meta">@GetMapping(&quot;/hello&quot;)</span><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="string">&quot;hello,kuangshen&quot;</span>;&#125;&#125;</code></pre><p>3、启动测试下，端口修改下，避免8080冲突！本地访问没问题就可以！</p><p>4、打jar包</p><p><img src="/posts/34285/image-20211010223916639.webp" alt="image-20211010223916639"></p><p>有了 jar 包，我们就可以作镜像了！ 记得测试一下jar包可以使用吗！</p><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>1、在项目下编写 Dockerfile 文件，将打包好的jar包拷贝到Dockerfile同级目录</p><pre><code class="highlight dockerfile"><span class="keyword">FROM</span> java:<span class="number">8</span><span class="comment"># 服务器只有dockerfile和jar在同级目录</span><span class="keyword">COPY</span><span class="language-bash"> *.jar /app.jar</span><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--server.port=8080&quot;</span>]</span><span class="comment"># 指定容器内要暴露的端口</span><span class="keyword">EXPOSE</span> <span class="number">8080</span><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span></code></pre><p>2、将Dockerfile 和 项目的 jar 包上传到linux服务器上，构建运行</p><pre><code class="highlight shell">[root@kuangshen idea]# pwd/home/idea[root@kuangshen idea]# lltotal 17228-rw-r--r-- 1 root root 17634294 May 14 12:33 demo-0.0.1-SNAPSHOT.jar-rw-r--r-- 1 root root 207 May 14 12:32 Dockerfile<span class="meta prompt_"># </span><span class="language-bash">构建镜像</span>docker build -t idea-ks .<span class="meta prompt_"># </span><span class="language-bash">查看镜像</span>docker images<span class="meta prompt_"># </span><span class="language-bash">运行</span>docker run -d -P --name idea-ks idea-ks[root@kuangshen ~]# docker psCONTAINER ID IMAGE PORTS NAMES2366c960ba99 idea-ks 0.0.0.0:32779-&gt;8080/tcp idea-ks1<span class="meta prompt_"># </span><span class="language-bash">测试访问</span>[root@kuangshen ~]# curl localhost:32779[root@kuangshen ~]# curl localhost:32779/hello</code></pre><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="安装Docker-compose"><a href="#安装Docker-compose" class="headerlink" title="安装Docker-compose"></a>安装Docker-compose</h2><p>1、下载安装</p><pre><code class="highlight shell">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose<span class="meta prompt_"></span><span class="meta prompt_"># </span><span class="language-bash">这个可能快点！</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose<span class="meta prompt_"># </span><span class="language-bash">添加执行权限</span>sudo chmod +x /usr/local/bin/docker-compose</code></pre><p>2、体验</p><h2 id="博客WordPress"><a href="#博客WordPress" class="headerlink" title="博客WordPress"></a>博客WordPress</h2><p>1、下载，安装数据库、配置、、</p><p>compse应用—》一键启动</p><p>1、下载项目（docker-compose.yam)</p><p>2、如果需要文件，dockerfile</p><p>3、文件准备齐全一键启动</p><p>创建docker-compose.yml</p><p>将下面脚本写入</p><p>然后执行docker-compose up</p><pre><code class="highlight shell">version: &quot;3.9&quot;    services:  db:    image: mysql:5.7    volumes:      - db_data:/var/lib/mysql    restart: always    environment:      MYSQL_ROOT_PASSWORD: somewordpress      MYSQL_DATABASE: wordpress      MYSQL_USER: wordpress      MYSQL_PASSWORD: wordpress      wordpress:    depends_on:      - db    image: wordpress:latest    volumes:      - wordpress_data:/var/www/html    ports:      - &quot;8000:80&quot;    restart: always    environment:      WORDPRESS_DB_HOST: db:3306      WORDPRESS_DB_USER: wordpress      WORDPRESS_DB_PASSWORD: wordpress      WORDPRESS_DB_NAME: wordpressvolumes:  db_data: &#123;&#125;  wordpress_data: &#123;&#125;</code></pre><p>前台启动</p><p>docker -d</p><p>docker-compose up -d</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python列表</title>
      <link href="/posts/19235.html"/>
      <url>/posts/19235.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/19235/image-20211006000059728.webp" alt="image-20211006000059728"></p><p>pycharm Code 配置</p><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : $&#123;DATE&#125; $&#123;TIME&#125;</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : $&#123;NAME&#125;.py</span><span class="comment"># @Sofware : $&#123;PRODUCT_NAME&#125;</span></code></pre><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/3/8 10:46</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : list01.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment">#</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">翻转：reverse()</span><span class="string"></span><span class="string">pop 弹栈 移除列表最后一个，返回值是删除的那个元素</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span>hotpot_list = [<span class="string">&#x27;海底捞&#x27;</span>, <span class="string">&#x27;呷哺&#x27;</span>, <span class="string">&#x27;张亮麻辣烫&#x27;</span>, <span class="string">&#x27;热辣一号&#x27;</span>, <span class="string">&#x27;宽板凳&#x27;</span>]hotpot_list.append(<span class="string">&#x27;张亮麻辣烫&#x27;</span>)<span class="built_in">print</span>(hotpot_list)<span class="built_in">print</span>(hotpot_list.remove(<span class="string">&#x27;张亮麻辣烫&#x27;</span>))<span class="built_in">print</span>(hotpot_list)<span class="built_in">print</span>(hotpot_list.pop())<span class="built_in">print</span>(hotpot_list)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">sorted(lits)</span><span class="string">list.sort()</span><span class="string">&#x27;&#x27;&#x27;</span>l = [<span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">68</span>, <span class="number">9</span>]l.sort(reverse=<span class="literal">False</span>)  <span class="comment"># 升序</span><span class="built_in">print</span>(l)<span class="comment"># # 声明</span>names = [<span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;lucy&#x27;</span>, <span class="string">&#x27;superman&#x27;</span>, <span class="string">&#x27;ironman&#x27;</span>]computer_brands = []<span class="comment">#</span><span class="comment"># # 地址</span><span class="comment"># print(id(names))</span><span class="comment"># print(id(computer_brands))</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># # 元素的获取： 下标  索引</span><span class="comment"># print(names[0])</span><span class="comment"># print(names[1])</span><span class="comment">#</span><span class="comment"># # 获取最后一个元素</span><span class="comment"># print(names[-1])</span><span class="comment">#</span><span class="comment"># # 结合循环</span><span class="built_in">print</span>(<span class="string">&#x27;___________________&#x27;</span>)<span class="keyword">for</span> name <span class="keyword">in</span> names:    <span class="built_in">print</span>(name)<span class="comment">#</span><span class="comment"># # 查询names里面有没有保存超人</span><span class="comment"># print(&#x27;________________&#x27;)</span><span class="comment"># for name in names:</span><span class="comment">#     if name == &#x27;superman&#x27;:</span><span class="comment">#         print(name)</span><span class="comment">#         break</span><span class="comment"># else:</span><span class="comment">#     print(&#x27;没有超人在里面&#x27;)</span><span class="comment">#</span><span class="comment"># # 简便</span><span class="comment"># if &#x27;superman&#x27; in names:     # 判断有没有</span><span class="comment">#     print(&#x27;有超人在里面&#x27;)</span><span class="comment"># else:</span><span class="comment">#     print(&#x27;没有超人在里面&#x27;)</span><span class="comment">#</span></code></pre><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/3/8 11:07</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : list02.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment"># 增删改</span>brands = [<span class="string">&#x27;hp&#x27;</span>, <span class="string">&#x27;dell&#x27;</span>, <span class="string">&#x27;thinkpad&#x27;</span>, <span class="string">&#x27;支持华为&#x27;</span>, <span class="string">&#x27;lenovo&#x27;</span>, <span class="string">&#x27;mac&#x27;</span>, <span class="string">&#x27;神舟&#x27;</span>]<span class="comment"># 改</span><span class="built_in">print</span>(brands)<span class="built_in">print</span>(brands[-<span class="number">1</span>])brands[-<span class="number">1</span>] = <span class="string">&#x27;HASEE&#x27;</span>  <span class="comment"># 赋值 步骤：1.找到(使用下标）</span><span class="built_in">print</span>(brands)<span class="built_in">print</span>(<span class="string">&#x27;+++++++++++&#x27;</span>)<span class="comment"># HUAWEI</span><span class="comment"># for brand in brands:</span><span class="comment">#     if &#x27;华为&#x27; in brand:</span><span class="comment">#         brands[brands.index(&#x27;华为&#x27;)] = &#x27;HUAWEI&#x27;</span><span class="comment">#         print(brands)</span><span class="comment">#         break</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(brands)):    <span class="keyword">if</span> <span class="string">&#x27;华为&#x27;</span> <span class="keyword">in</span> brands[i]:        brands[i] = <span class="string">&#x27;HUAWEI&#x27;</span>        <span class="keyword">break</span><span class="built_in">print</span>(brands)<span class="comment"># 删除 del</span><span class="comment"># del brands[2]</span><span class="comment"># print(brands)</span><span class="comment"># 删除 只要是hp，mac 都要删除</span><span class="comment"># for i in range(len(brands)):</span><span class="comment">#     if &#x27;hp&#x27; in brands[i]:</span><span class="comment">#         del brands[i]</span><span class="comment">#     if &#x27;mac&#x27; in brands[i]:</span><span class="comment">#         del brands[i]</span><span class="comment">#         break</span><span class="comment"># print(brands)</span>l = <span class="built_in">len</span>(brands)i = <span class="number">0</span><span class="keyword">while</span> i &lt; l:    <span class="keyword">if</span> <span class="string">&#x27;hp&#x27;</span> <span class="keyword">in</span> brands[i] <span class="keyword">or</span> <span class="string">&#x27;mac&#x27;</span> <span class="keyword">in</span> brands[i]:        <span class="keyword">del</span> brands[i]        l -= <span class="number">1</span>        <span class="keyword">continue</span>    i += <span class="number">1</span><span class="built_in">print</span>(brands)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">they are students</span><span class="string">yews</span><span class="string">[&#x27;hello&#x27;, &#x27;good&#x27;, &#x27;apple&#x27;, &#x27;world&#x27;, &#x27;digit&#x27;, &#x27;alpha&#x27;]</span><span class="string">hello</span><span class="string">&#x27;&#x27;&#x27;</span>name_list = [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;good&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;digit&#x27;</span>, <span class="string">&#x27;alpha&#x27;</span>]result = <span class="built_in">input</span>(<span class="string">&#x27;请输入要删除的元素：&#x27;</span>)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(name_list)):    <span class="keyword">if</span> result <span class="keyword">in</span> name_list[i]:        <span class="keyword">del</span> name_list[i]        <span class="keyword">break</span><span class="built_in">print</span>(name_list)</code></pre><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/3/8 12:50</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : list04.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment"># s = &#x27;abcdefg&#x27; s[2:5]</span>list1 = [<span class="string">&#x27;杨超越&#x27;</span>, <span class="string">&#x27;迪丽热巴&#x27;</span>, <span class="string">&#x27;佟丽娅&#x27;</span>, <span class="string">&#x27;杨幂&#x27;</span>, <span class="string">&#x27;赵丽颖&#x27;</span>, <span class="string">&#x27;刘亦菲&#x27;</span>, <span class="string">&#x27;黑嘉嘉&#x27;</span>, <span class="number">100</span>, <span class="number">99.99</span>]<span class="built_in">print</span>(list1)<span class="built_in">print</span>(list1[<span class="number">3</span>])<span class="built_in">print</span>(list1.index(<span class="string">&#x27;杨幂&#x27;</span>))<span class="comment"># 切片</span><span class="built_in">print</span>(list1[<span class="number">3</span>:<span class="number">6</span>])<span class="built_in">print</span>(list1[-<span class="number">3</span>:-<span class="number">1</span>])<span class="built_in">print</span>(list1[-<span class="number">1</span>::-<span class="number">1</span>])</code></pre><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/3/8 13:15</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : list05.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment">#</span><span class="comment"># # list列表添加</span><span class="comment"># # 临时小数据库</span><span class="comment">#</span><span class="comment"># # 创建一个空列表</span><span class="comment">#</span><span class="comment"># girls = []</span><span class="comment"># # quit 表示退出</span><span class="comment"># # while True:</span><span class="comment"># #     name = input(&#x27;请输入你心目中的美女的名字：&#x27;)</span><span class="comment"># #     if name == &#x27;quit&#x27;:</span><span class="comment"># #         break</span><span class="comment"># #     # 列表的函数使用：append extends insert</span><span class="comment"># #     # append() 末尾追加</span><span class="comment"># #     girls.append(name)</span><span class="comment"># #</span><span class="comment"># # print(girls)</span><span class="comment">#</span><span class="comment"># # extend 类似列表的合并</span><span class="comment">#</span><span class="comment"># names = [&#x27;黑嘉嘉&#x27;, &#x27;孙俪&#x27;, &#x27;巩俐&#x27;, &#x27;王丽坤&#x27;]</span><span class="comment"># # name = input(&#x27;请输入你心目中的美女的名字：&#x27;)</span><span class="comment"># girls.extend(names)</span><span class="comment"># print(girls)</span><span class="comment">#</span><span class="comment"># # 符号 + 也可以用于列表的合并</span><span class="comment"># girls = girls+names</span><span class="comment"># print(girls)</span><span class="comment">#</span><span class="comment"># # insert 插入</span><span class="comment"># # [&#x27;杨幂&#x27;, &#x27;黑嘉嘉&#x27;, &#x27;孙俪&#x27;, &#x27;巩俐&#x27;, &#x27;王丽坤&#x27;]</span><span class="comment"># #   0         1        2    3       4</span><span class="comment">#</span><span class="comment"># # append 末尾添加</span><span class="comment"># # insert 指定位置添加</span><span class="comment"># # extend 一次添加多个元素</span><span class="comment"># girls.insert(1,&#x27;刘涛&#x27;)</span><span class="comment"># print(girls)</span><span class="comment">#</span><span class="comment"># print(&#x27;--------------&#x27;)</span><span class="comment">#</span><span class="comment"># # 产生10个随机数，将其保存在列表</span><span class="comment">#</span><span class="comment"># import random</span><span class="comment">#</span><span class="comment"># random_list = []</span><span class="comment"># # for i in range(10):</span><span class="comment"># #     ran = random.randint(1, 99)</span><span class="comment"># #     random_list.append(ran)</span><span class="comment"># # print(random_list)</span><span class="comment"># # random_list = []</span><span class="comment"># # for i in range(10):</span><span class="comment"># #     ran = random.randint(1, 10)</span><span class="comment"># #     # if ran in random_list:</span><span class="comment"># #     #     pass</span><span class="comment"># #     # else:</span><span class="comment"># #     #     random_list.append(ran)</span><span class="comment"># #     if ran not in random_list:</span><span class="comment"># #         random_list.append(ran)</span><span class="comment"># # print(random_list)</span><span class="comment"># i = 0</span><span class="comment">#</span><span class="comment"># while i &lt; 10:</span><span class="comment">#     ran = random.randint(0, 99)</span><span class="comment">#     if ran not in random_list:</span><span class="comment">#         random_list.append(ran)</span><span class="comment">#         i += 1</span><span class="comment"># print(random_list)</span><span class="comment"># # 找出列表最大值</span><span class="comment"># print(max(random_list))</span><span class="comment"># print(min(random_list))</span><span class="comment"># print(&#x27;--------------求最大值-------------&#x27;)</span><span class="comment">#</span><span class="comment"># mvalue = random_list[0]</span><span class="comment"># minvalue = random_list[0]</span><span class="comment"># for i in random_list:</span><span class="comment">#     if i &gt; mvalue:</span><span class="comment">#         mvalue = i</span><span class="comment">#     if i &lt; minvalue:</span><span class="comment">#         minvalue = i</span><span class="comment">#</span><span class="comment"># print(&#x27;最大值：%s，最小值：%s&#x27; % (mvalue, minvalue))</span><span class="comment">#</span><span class="comment"># print(&#x27;求和&#x27;)</span><span class="comment">#</span><span class="comment"># print(&#x27;计算机求和&#x27;, sum(random_list))</span><span class="comment">#</span><span class="comment"># # 声明累加的变量和</span><span class="comment"># sum = 0</span><span class="comment"># for i in random_list:</span><span class="comment">#     sum *= i</span><span class="comment"># print(sum)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># # 排序：sort排序</span><span class="comment">#</span><span class="comment"># print(sorted(random_list, reverse=True))</span><span class="built_in">print</span>(<span class="string">&#x27;-------自己写排序------&#x27;</span>)<span class="comment"># 自己写排序</span>num_list1 = [<span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]num_list2 = []<span class="keyword">for</span> i <span class="keyword">in</span> num_list1:    <span class="keyword">for</span> b <span class="keyword">in</span> num_list1[i + <span class="number">1</span>]:        <span class="keyword">if</span> i &gt; b:            num_list2.append(num_list1)<span class="comment"># while i &lt; len(num_list1):</span><span class="comment">#     if num_list1[i] &lt; num_list1[i+1]:</span><span class="comment">#         num_list2.append(num_list1[i])</span><span class="comment">#         i += 1</span><span class="comment">#     else:</span><span class="comment">#         num_list2.append(num_list1[i])</span><span class="comment">#         i += 1</span><span class="comment"># print(num_list2)</span></code></pre><pre><code class="highlight python"><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/3/14 12:29</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : list_算法.py</span><span class="comment"># @Sofware : PyCharm</span><span class="string">&quot;&quot;&quot;</span><span class="string">str()</span><span class="string">int()</span><span class="string">len()</span><span class="string">list()</span><span class="string">sorted()</span><span class="string">print()</span><span class="string">input()</span><span class="string">enumerate():函数用于将一个可遍历的数据对象（如列表，元组或字符串）组合微一个案例</span><span class="string">&quot;&quot;&quot;</span><span class="comment"># l1 = [&#x27;a&#x27;, &#x27;abc&#x27;, &#x27;jk&#x27;, &#x27;opop&#x27;]</span><span class="comment"># for index, value in enumerate(l1):</span><span class="comment">#     print(index, value)</span>numbers = [<span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">96</span>, <span class="number">3</span>, <span class="number">5</span>]<span class="comment"># print(numbers.sort(reverse=True))</span><span class="comment"># print(numbers)</span><span class="comment"># print(sorted(numbers))</span><span class="comment"># 自定义排序方法</span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(numbers)):    <span class="comment"># number[i] = 5</span>    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(numbers)):        <span class="keyword">if</span> numbers[i] &gt; numbers[j]:            <span class="comment"># 快速交换位置</span>            numbers[i], numbers[j] = numbers[j], numbers[i]<span class="built_in">print</span>(numbers)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python函数调用</title>
      <link href="/posts/28879.html"/>
      <url>/posts/28879.html</url>
      
        <content type="html"><![CDATA[<h1 id="函数嵌套调用"><a href="#函数嵌套调用" class="headerlink" title="函数嵌套调用"></a>函数嵌套调用</h1><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">a</span>():    <span class="built_in">print</span>(<span class="string">&#x27;AAAAAAA&#x27;</span>)<span class="keyword">def</span> <span class="title function_">b</span>():    <span class="comment"># 调用函数a</span>    a()    <span class="built_in">print</span>(<span class="string">&#x27;BBBBBBB&#x27;</span>)<span class="keyword">def</span> <span class="title function_">c</span>():    b()    <span class="built_in">print</span>(<span class="string">&#x27;CCCCCCC&#x27;</span>)c()</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code class="highlight python"><span class="comment"># 定义函数：随机数产生</span><span class="comment"># 自动格式化Ctrl+Alt+L</span><span class="keyword">import</span> random<span class="keyword">def</span> <span class="title function_">generate_random</span>():    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):        ran = random.randint(<span class="number">1</span>, <span class="number">20</span>)        <span class="built_in">print</span>(ran)<span class="built_in">print</span>(generate_random)<span class="comment"># &lt;function generate_random at 0x000002755D17E040&gt;</span><span class="comment">#  函数名      函数           在  内存地址</span><span class="comment"># 调用：函数名() 找到函数并执行函数体</span><span class="built_in">print</span>(<span class="string">&#x27;------1------&#x27;</span>)generate_random()<span class="built_in">print</span>(<span class="string">&#x27;------2------&#x27;</span>)generate_random()</code></pre><pre><code class="highlight python"><span class="comment"># 函数：带参数的</span><span class="keyword">import</span> random<span class="keyword">def</span> <span class="title function_">generate_random</span>(<span class="params">ran, ranmin, ranmax</span>):  <span class="comment"># 形参，用来占位的参数，这里是ran，ranmin，ranmax</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ran):        ran1 = random.randint(ranmin, ranmax)        <span class="built_in">print</span>(ran1)num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入要产生的随机数个数：&#x27;</span>))num2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入要产生的随机数范围最小值：&#x27;</span>))num3 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入要产生的随机数范围最大值：&#x27;</span>))generate_random(num, num2, num3)  <span class="comment"># 实参 实际参数，具体的值</span><span class="comment"># 求加法的函数</span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):    <span class="built_in">print</span>(<span class="string">&#x27;加起来等于&#x27;</span>, a + b)a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入第一个数：&#x27;</span>))b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入第二个数：&#x27;</span>))add(a, b)</code></pre><pre><code class="highlight python"><span class="string">&quot;&quot;&quot;</span><span class="string">定义一个登录的函数，参数是：username，password</span><span class="string">函数体：</span><span class="string">判断参数传过来的是username，password是否正确，如果正确则登录成功，否则打印失败</span><span class="string"></span><span class="string">&quot;&quot;&quot;</span><span class="comment"># 函数的定义</span><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):    uname = <span class="string">&#x27;admin123&#x27;</span>    pwd = <span class="string">&#x27;112233&#x27;</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):        <span class="keyword">if</span> username == uname <span class="keyword">and</span> password == pwd:            <span class="built_in">print</span>(<span class="string">&#x27;输入正确&#x27;</span>)            <span class="keyword">break</span>        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">&#x27;输入错误&#x27;</span>)            username = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入用户名：&#x27;</span>))            password = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入密码：&#x27;</span>))    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;账户锁定！&#x27;</span>)username = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入用户名：&#x27;</span>))password = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入密码：&#x27;</span>))login(username, password)</code></pre><pre><code class="highlight python"><span class="comment"># 找出列表的最大值</span><span class="comment"># 自己封装一个求最大值函数</span><span class="keyword">def</span> <span class="title function_">max</span>(<span class="params">iterable</span>):    <span class="built_in">max</span> = iterable[<span class="number">0</span>]    <span class="keyword">for</span> i <span class="keyword">in</span> iterable:        <span class="keyword">if</span> i &gt; <span class="built_in">max</span>:            <span class="built_in">max</span> = i    <span class="built_in">print</span>(<span class="string">&#x27;最大值是：&#x27;</span>, <span class="built_in">max</span>)<span class="comment"># 调用：测试是否能找出最大值</span>list1 = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>]<span class="built_in">max</span>(list1)tuple1 = (<span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>)<span class="built_in">max</span>(tuple1)<span class="comment"># sort min reverse</span><span class="built_in">print</span>(<span class="built_in">type</span>(tuple1))  <span class="comment"># 查看是什么类型</span><span class="comment"># 判断是不是什么类型：isinstance</span><span class="built_in">print</span>(<span class="built_in">isinstance</span>(<span class="number">2</span>, <span class="built_in">int</span>))  <span class="comment"># 返回值是False，True</span><span class="built_in">print</span>(<span class="built_in">isinstance</span>(tuple1, <span class="built_in">tuple</span>))</code></pre><pre><code class="highlight python"><span class="comment"># 可变参数</span><span class="comment"># def add(*args):</span><span class="comment">#     print(args)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># add(1)</span><span class="comment"># 定义方式</span><span class="comment"># def add(*args):</span><span class="comment">#     # *args的用法：当传入的参数个数未知，且不需要知道参数名称时。</span><span class="comment">#     # print(args)</span><span class="comment">#     sum = 0</span><span class="comment">#     if len(args) &gt; 0:</span><span class="comment">#         for i in args:</span><span class="comment">#             sum += i</span><span class="comment">#         print(&#x27;累加的和是sum:&#x27;, sum)</span><span class="comment">#     else:</span><span class="comment">#         print(&#x27;没有元素可计算，sum：&#x27;, sum)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># add()</span><span class="comment"># add(1)</span><span class="comment"># add(1, 2)</span><span class="comment"># add(1, 2, 3, 4)</span><span class="comment"># xxx计算出来的累加和是：xxx</span><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name, age, *args</span>):    <span class="comment"># **args的用法：当传入的参数个数未知，但需要知道参数的名称时(立马想到了字典，即键值对)</span>    <span class="built_in">print</span>(args, name)    <span class="built_in">sum</span> = <span class="number">0</span>    <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> args:            <span class="built_in">sum</span> += i        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;累加的和：sum：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, <span class="built_in">sum</span>))    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;没有元素可计算：sum：&#x27;</span>, <span class="built_in">sum</span>)<span class="comment"># 调用</span>add(<span class="string">&#x27;菲菲&#x27;</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)<span class="comment"># 注意：可变参数必须放在后面：name，*args</span>add(<span class="string">&#x27;我&#x27;</span>, <span class="number">10</span>)<span class="comment"># name,age, *args=&#x27;我&#x27;,10</span></code></pre><pre><code class="highlight python"><span class="comment"># # 可变参数 + 关键字参数</span><span class="comment"># # 关键字参数：key=value 键值对</span><span class="comment">#</span><span class="comment"># def add(a, b=10):  # 关键字参数</span><span class="comment">#     result = a + b</span><span class="comment">#     print(result)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># # 调用</span><span class="comment"># add(5)</span><span class="comment"># add(4, 7)  # a=4,b=7   覆盖默认值</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def add1(a, b=10, c=4):</span><span class="comment">#     result = a + b + c</span><span class="comment">#     print(result)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># add1(1)</span><span class="comment"># add1(1, 5)  # 给b赋值</span><span class="comment"># add1(1, c=6)  # 直接将6赋值给c</span><span class="comment">#</span><span class="comment"># # 函数：打印每位同学姓名和年龄</span><span class="comment">#</span>studens = &#123;    <span class="string">&#x27;001&#x27;</span>: (<span class="string">&#x27;蔡徐坤&#x27;</span>, <span class="number">20</span>),    <span class="string">&#x27;002&#x27;</span>: (<span class="string">&#x27;王源&#x27;</span>, <span class="number">18</span>),    <span class="string">&#x27;003&#x27;</span>: (<span class="string">&#x27;王俊凯&#x27;</span>, <span class="number">21</span>),    <span class="string">&#x27;004&#x27;</span>: (<span class="string">&#x27;易烊千玺&#x27;</span>, <span class="number">19</span>)&#125;<span class="keyword">def</span> <span class="title function_">print_boy</span>(<span class="params">name, **persons</span>):    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;喜欢吃肉肉&#x27;</span>.<span class="built_in">format</span>(name))    <span class="keyword">if</span> <span class="built_in">isinstance</span>(persons, <span class="built_in">dict</span>):  <span class="comment"># 判断是不是什么类型：isinstance，这里判断是不是person是不是字典类型</span>        values = persons.values()  <span class="comment"># 如果是字典，那么使用values接受字典里面的键值对</span>        <span class="comment"># print(values)             # 输出字典</span>        <span class="keyword">for</span> name, age <span class="keyword">in</span> values:  <span class="comment"># 使用name和age接受values中的键值对</span>            <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;的年龄是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, age))  <span class="comment"># 循环输出字典中的元素</span>print_boy(<span class="string">&#x27;健健&#x27;</span>, **studens)<span class="comment">#</span><span class="comment">#</span><span class="comment"># def func(**key):</span><span class="comment">#     print(key)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># func(a=1, b=1, c=1)</span><span class="comment"># dict1 = &#123;&#x27;001&#x27;: &#x27;python&#x27;, &#x27;002&#x27;: &#x27;java&#x27;, &#x27;004&#x27;: &#x27;c++&#x27;&#125;</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># func(**dict1)</span></code></pre><pre><code class="highlight python"><span class="string">&quot;&quot;&quot;</span><span class="string">使用函数的时候：</span><span class="string">def aa(*kwargs):</span><span class="string">    pass</span><span class="string">&quot;&quot;&quot;</span><span class="keyword">def</span> <span class="title function_">aa</span>(<span class="params">**kwargs</span>):  <span class="comment"># 只要在定义函数的时候加入**就是装包</span>    <span class="built_in">print</span>(kwargs)aa(a=<span class="number">1</span>, b=<span class="string">&#x27;hello&#x27;</span>, c=<span class="string">&#x27;tom&#x27;</span>)  <span class="comment"># 装包成字典</span><span class="comment"># 如果在开发的时候，已知一个字典</span>dict1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;tom&#x27;</span>&#125;aa(**dict1)  <span class="comment"># 只要在调用函数的时候加入**就是拆包</span><span class="keyword">def</span> <span class="title function_">bb</span>(<span class="params">a, b, *c, **d</span>):    <span class="built_in">print</span>(a, b, c, d)bb(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 打印两个参数 1 2 一个元组，一个字典</span>bb(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 打印 ，1 2 (3,4) &#123;&#125;</span>bb(<span class="number">1</span>, <span class="number">2</span>, x=<span class="number">100</span>, y=<span class="number">200</span>)  <span class="comment"># 1 2 () &#123;&#x27;x&#x27;:100,&#x27;y&#x27;:200&#125;</span>bb(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, x=<span class="number">100</span>)  <span class="comment"># 1 2 (3,) &#123;&#x27;x&#x27;:100&#125;</span>bb(<span class="number">1</span>, <span class="number">2</span>, x=<span class="number">100</span>)</code></pre><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *args</span>):    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, args))func(<span class="number">2</span>, [<span class="number">1</span>, <span class="number">23</span>, <span class="number">4</span>], <span class="string">&#x27;fad&#x27;</span>)<span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a, b=<span class="number">10</span>, c=<span class="number">3</span>, **kwargs</span>):    <span class="built_in">print</span>(a, b, c, kwargs)func2(<span class="number">1</span>)  <span class="comment"># 1 10 3 &#123;&#125;  给默认值所以可传入一个参数</span>func2(<span class="number">2</span>, b=<span class="number">11</span>)  <span class="comment"># 2 11 3 &#123;&#125;</span>func2(<span class="number">3</span>, c=<span class="number">5</span>, b=<span class="number">7</span>, x=<span class="number">1</span>, y=<span class="number">2</span>)  <span class="comment"># 3 7 5 &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;，传值的时候可以打乱位置</span><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">a, *args, **kwargs</span>):    <span class="built_in">print</span>(a, args, kwargs)t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)func3(<span class="number">1</span>, t)  <span class="comment"># 1 ((1, 2, 3, 4),) &#123;&#125;</span>l = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]func3(<span class="number">1</span>, l, c=<span class="number">9</span>, b=<span class="number">6</span>)  <span class="comment"># 1 ([2, 5, 8],) &#123;&#x27;c&#x27;: 9, &#x27;b&#x27;: 6&#125;</span>dict1 = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;c&#x27;</span>&#125;func3(<span class="number">1</span>, *l, **dict1)  <span class="comment"># 1 (2, 5, 8) &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;        # *拆列表 **拆字典</span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">name, *args</span>):    <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> args:  <span class="comment"># 这里args是元组</span>            <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;学过了&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, i))    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;没有学过任何语言&#x27;</span>)courses = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;c++&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]<span class="comment"># 调用函数</span>func1(<span class="string">&#x27;健健&#x27;</span>, *courses)  <span class="comment"># *拆列表（拆包）</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">无参数函数：</span><span class="string">    def func():</span><span class="string">        pass</span><span class="string">    func() ---调用</span><span class="string">    </span><span class="string">    有参数函数</span><span class="string">1.普通参数</span><span class="string">    def func(name,age):</span><span class="string">        pass</span><span class="string">    func(&#x27;aa&#x27;,19) ---&gt;形参与实参的个数要一致</span><span class="string"></span><span class="string">2.可变参数：</span><span class="string">    A.</span><span class="string">        def func(*args):</span><span class="string">            pass</span><span class="string">        func() ----&gt; 函数调用时，实参的个数可以没有，也可以多个，*不能是关键字参数</span><span class="string">        func(4) </span><span class="string">        func(5,&#x27;h&#x27;)</span><span class="string"></span><span class="string">    B.</span><span class="string">        def func(**kwargs):</span><span class="string">            pass</span><span class="string">        func(a=1,b=2)----&gt; 函数调用时，实参的个数可以没有，也可以多个，**必须是关键字参数</span><span class="string">    </span><span class="string">    C.</span><span class="string">        def func(*args,**kwargs):</span><span class="string">            pass</span><span class="string">        list1 = [1,2,3,4,5]</span><span class="string">        dict1 = &#123;&#x27;1&#x27;:&#x27;a&#x27;,&#x27;2&#x27;:&#x27;b&#x27;,&#x27;3&#x27;:&#x27;c&#x27;&#125;</span><span class="string">        func(*list1,**dict1)    拆包func(1,2,3,4,5,&#x27;1&#x27;:&#x27;a&#x27;,&#x27;2&#x27;:&#x27;b&#x27;,&#x27;3&#x27;:&#x27;c&#x27;)</span><span class="string">    </span><span class="string">    D.混用</span><span class="string">        def func(name,*args,*8kwargs):</span><span class="string">            pass</span><span class="string">        func(&#x27;tom&#x27;) ----&gt;必须赋值</span><span class="string">3.默认值</span><span class="string">    def func(name,age=18):</span><span class="string">        pass</span><span class="string">    func(&#x27;tom&#x27;) ----&gt; tom 18</span><span class="string">    func(&#x27;tom&#x27;,age = 20) ----&gt;关键字赋值</span><span class="string">        </span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight python"><span class="comment"># 返回值：将函数中运算的结果通过return关键字‘扔’出来</span><span class="comment"># 如果使用print这个值就不会出来只会在def内部打印，外面是接受不到的</span><span class="comment"># def add(a, b):  # 加载</span><span class="comment">#     result = a + b</span><span class="comment">#     # print(result)</span><span class="comment">#     return &#x27;这都不会&#x27;, result</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># # 调用函数</span><span class="comment"># # add(2, 4) 这里只能打印函数中的print内容不会接收return</span><span class="comment"># x, y = add(2, 4)</span><span class="comment"># print(x, y)</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">return 返回值</span><span class="string">1.return后面可以是一个参数 接收的时候x=add(1,2)</span><span class="string"></span><span class="string">2.return后面也可以是多个参数，如果是多个参数则底层会将多个参数先放在一个元组中，</span><span class="string">    将元组作为整体返回 x=add(1,2) x--&gt; (1,2,3)</span><span class="string">3.接收的时候也可以是多个：return &#x27;hello&#x27;,&#x27;world&#x27; x,y = (&#x27;hello&#x27;,&#x27;world&#x27;) ---&gt;x = &#x27;hello&#x27; y = &#x27;world&#x27;</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight python"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">加入购物车</span><span class="string">判断用户是否登录，如果登录，成功加入购物车，否则提示请登录之后添加</span><span class="string">成功 True     不成功 False</span><span class="string">def add_shoppingcart(goodsName):</span><span class="string">    pass</span><span class="string">def login(username,password):</span><span class="string">    pass</span><span class="string"></span><span class="string">调用</span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># isLogin = False</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def add_shoppingcart(goodsName):</span><span class="comment">#     if isLogin and goodsName:</span><span class="comment">#         print(&#x27;成功将&#123;&#125;加入到购物车！！！&#x27;.format(goodsName))</span><span class="comment">#     else:</span><span class="comment">#         print(&#x27;用户没有登录！或者没有添加如何商品请登录之后添加&#x27;)</span><span class="comment">#     return isLogin</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def login(username, password):</span><span class="comment">#     if username == &#x27;zhao&#x27; and password == &#x27;123456&#x27;:</span><span class="comment">#         return True</span><span class="comment">#     else:</span><span class="comment">#         print(&#x27;登录失败用户名或者密码错误&#x27;)</span><span class="comment">#         return False</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># # 调用函数</span><span class="comment"># while True:</span><span class="comment">#     username = input(&#x27;输入用户名：&#x27;)</span><span class="comment">#     password = input(&#x27;输入密码：&#x27;)</span><span class="comment">#     isLogin = login(username, password)</span><span class="comment">#     y = add_shoppingcart(&#x27;榴莲&#x27;)</span><span class="comment">#     if isLogin:</span><span class="comment">#         break</span></code></pre><pre><code class="highlight python">isLogin = <span class="literal">False</span><span class="keyword">def</span> <span class="title function_">add_shoppingcart</span>(<span class="params">goodsName</span>):    <span class="keyword">global</span> isLogin    <span class="keyword">if</span> isLogin:        <span class="keyword">if</span> goodsName:            <span class="built_in">print</span>(<span class="string">&#x27;成功将&#123;&#125;加入到购物车！！！&#x27;</span>.<span class="built_in">format</span>(goodsName))        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">&#x27;没有选中任何商品&#x27;</span>)    <span class="keyword">else</span>:        answer = <span class="built_in">input</span>(<span class="string">&#x27;没有登录！是否登录(yes/no)&#x27;</span>)        <span class="keyword">if</span> answer == <span class="string">&#x27;yes&#x27;</span>:            <span class="comment"># 登录</span>            username = <span class="built_in">input</span>(<span class="string">&#x27;输入用户名：&#x27;</span>)            password = <span class="built_in">input</span>(<span class="string">&#x27;输入密码：&#x27;</span>)            <span class="comment"># 调用login</span>            isLogin = login(username, password)  <span class="comment"># 在一个函数中调用另外一个函数 将login函数中return的值赋值给islogin</span>            <span class="built_in">print</span>(isLogin)            <span class="keyword">return</span> isLogin        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">&#x27;很遗憾，不能添加如何商品&#x27;</span>)    <span class="keyword">return</span> isLogin<span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">username, password</span>):    <span class="keyword">if</span> username == <span class="string">&#x27;zhao&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123456&#x27;</span>:        <span class="keyword">return</span> <span class="literal">True</span>    <span class="keyword">else</span>:        <span class="keyword">return</span> <span class="literal">False</span><span class="comment"># 调用函数</span>username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)<span class="comment"># shoping = input(&quot;请输入你要买的商品：&quot;)</span><span class="comment"># add_shoppingcart(shoping)</span>isLogin = login(username, password)add_shoppingcart(<span class="string">&quot;isLogin&quot;</span>)</code></pre><pre><code class="highlight python"><span class="comment"># # 函数综合应用</span><span class="comment"># &#x27;&#x27;&#x27;</span><span class="comment">#     用户登录</span><span class="comment">#     输入密码</span><span class="comment">#     输入验证码 ---&gt;封装函数</span><span class="comment"># &#x27;&#x27;&#x27;</span><span class="keyword">import</span> random<span class="comment">#</span><span class="comment"># 我写的</span><span class="comment"># def yzm():</span><span class="comment">#     # 生成验证码</span><span class="comment">#     code = &#x27;&#x27;</span><span class="comment">#     ymzs = &#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0987654321&#x27;</span><span class="comment">#     for i in range(4):</span><span class="comment">#         a = random.randint(0, len(ymzs) - 1)</span><span class="comment">#         code += ymzs[a]</span><span class="comment">#     print(&#x27;验证码是&#x27;, code)</span><span class="comment">#     return code</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def yz(codes):</span><span class="comment">#     # 判断验证码</span><span class="comment">#     if codes == x:</span><span class="comment">#         return &#x27;验证码正确&#x27;</span><span class="comment">#         # print(&#x27;验证码正确&#x27;)</span><span class="comment">#     else:</span><span class="comment">#         return &#x27;验证码错误&#x27;</span><span class="comment">#         # print(&#x27;验证码错误&#x27;)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def login(username, password, codes, x):</span><span class="comment">#     if username == &#x27;1&#x27; and password == &#x27;1&#x27; and codes == x.lower():</span><span class="comment">#         print(&#x27;登录成功&#x27;)</span><span class="comment">#     if codes != x.lower():</span><span class="comment">#         print(&#x27;登录失败，验证码错误&#x27;)</span><span class="comment">#     else:</span><span class="comment">#         print(&#x27;登录失败，密码或用户名错误&#x27;)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># x = yzm()</span><span class="comment"># username = input(&#x27;请输入用户名：&#x27;)</span><span class="comment"># password = input(&#x27;请输入密码：&#x27;)</span><span class="comment"># codes = input(&#x27;请输入验证码&#x27;)</span><span class="comment"># cdoes = codes.lower()</span><span class="comment"># login(username, password, codes, x)</span><span class="comment"># if codes == x.lower():</span><span class="comment">#     print(&#x27;验证码正确&#x27;)</span><span class="comment"># else:</span><span class="comment">#     print(&#x27;登录失败，验证码错误&#x27;)</span><span class="comment"># 定义一个生成验证码函数   老师写的</span><span class="keyword">def</span> <span class="title function_">generate_chekcode</span>(<span class="params">n</span>):    code = <span class="string">&#x27;&#x27;</span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):        str1 = <span class="string">&#x27;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0987654321&#x27;</span>        a = random.randint(<span class="number">0</span>, <span class="built_in">len</span>(str1) - <span class="number">1</span>)        code += str1[a]    <span class="keyword">return</span> code<span class="comment"># 定义登录函数</span><span class="keyword">def</span> <span class="title function_">login</span>():    username = <span class="built_in">input</span>(<span class="string">&#x27;输入用户名：&#x27;</span>)    password = <span class="built_in">input</span>(<span class="string">&#x27;输入密码：&#x27;</span>)    <span class="comment"># 得到一个验证码</span>    code = generate_chekcode(<span class="number">5</span>)    <span class="built_in">print</span>(<span class="string">&#x27;验证码是：&#x27;</span>, code)    code1 = <span class="built_in">input</span>(<span class="string">&#x27;输入验证码：&#x27;</span>)    <span class="comment"># 验证</span>    <span class="keyword">if</span> code1.lower() == code.lower():        <span class="built_in">print</span>(<span class="string">&#x27;验证码正确&#x27;</span>)        <span class="keyword">if</span> username == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;admin&#x27;</span>:            <span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)        <span class="keyword">else</span>:            <span class="built_in">print</span>(<span class="string">&#x27;登录失败，用户名或密码有误！！！&#x27;</span>)    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;验证码不正确&#x27;</span>)login()</code></pre><pre><code class="highlight python"><span class="comment"># 局部和全局</span><span class="comment"># 如果修改的变量是全局变量时，在函数中修改时需要加global</span><span class="comment"># 如果修改的变量是可变的时候，不需要在函数中加global</span>name = <span class="string">&#x27;月月&#x27;</span>list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]<span class="keyword">def</span> <span class="title function_">func</span>():    name = <span class="string">&#x27;蕊蕊&#x27;</span>    <span class="built_in">print</span>(name)    <span class="built_in">print</span>(list1)<span class="keyword">def</span> <span class="title function_">func1</span>():    <span class="keyword">global</span> name    <span class="built_in">print</span>(name)    name += <span class="string">&#x27;真漂亮&#x27;</span>    list1.append(<span class="number">8</span>)    <span class="built_in">print</span>(list1)<span class="keyword">def</span> <span class="title function_">func2</span>():  <span class="comment"># 可以使用不同的变量名字来使用global，不要和global起一样的名字</span>    name1 = <span class="string">&#x27;lucy&#x27;</span>    name1 += <span class="string">&#x27;嘻嘻&#x27;</span>    <span class="keyword">global</span> name    <span class="built_in">print</span>(name)func1()func()func2()</code></pre><pre><code class="highlight python"><span class="comment"># global    变量的范围</span><span class="comment"># 局部变量    全局变量</span><span class="comment"># 声明在函数外层的是全局的，所有函数都可以访问。（不能修改）</span>name = <span class="string">&#x27;丽丽&#x27;</span><span class="keyword">def</span> <span class="title function_">func</span>():    <span class="comment"># 函数内部声明的变量，局部变量，局部变量仅限于函数内部使用</span>    s = <span class="string">&#x27;abcd&#x27;</span>    s += <span class="string">&#x27;X&#x27;</span>    <span class="built_in">print</span>(s, name)<span class="comment"># print(s) 报错</span><span class="keyword">def</span> <span class="title function_">func1</span>():    <span class="keyword">global</span> name  <span class="comment"># 声明我使用的是全局变量，声明之后就可以修改全局变量，</span>    <span class="comment"># print(s)</span>    <span class="built_in">print</span>(<span class="string">&#x27;没有修改的name&#x27;</span>, name)  <span class="comment"># 报错：函数内部的变量可以随便修改赋值，但是全局变量就不能随便修改</span>    name += <span class="string">&#x27;会吃shit&#x27;</span>    <span class="built_in">print</span>(<span class="string">&#x27;修改后的name&#x27;</span>, name)<span class="keyword">def</span> <span class="title function_">func2</span>():    name = <span class="string">&#x27;小丽丽&#x27;</span>    name += <span class="string">&#x27;弹吉他的小美女&#x27;</span>    <span class="built_in">print</span>(name)func2()func1()</code></pre><pre><code class="highlight python"><span class="comment"># 内部函数</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">特点：</span><span class="string">1、可以访问外部函数的变量</span><span class="string">2、内部函数可以修改外部函数的可变类型的变量比如：list1</span><span class="string">3、内部函数修改全局的不可变变量时，需要在内部函数声明global 变量名</span><span class="string">   内部函数修改外部函数的不可变的变量时，需要在内部函数中声明：nonlocal 变量名</span><span class="string">4、</span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">func</span>():    <span class="comment"># 声明变量</span>    n = <span class="number">100</span>  <span class="comment"># 内部函数</span>    list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]  <span class="comment"># 局部变量</span>    <span class="comment"># 声明内部函数</span>    <span class="keyword">def</span> <span class="title function_">inner_func</span>():        <span class="keyword">nonlocal</span> n  <span class="comment"># 加nonlocal可以修改内部函数，nonlocal 关键字用于在嵌套函数内部使用变量，其中变量不应属于内部函数。</span>        <span class="comment"># 对list1里面的元素进行加5操作</span>        <span class="keyword">for</span> index, i <span class="keyword">in</span> <span class="built_in">enumerate</span>(list1):  <span class="comment"># 枚举将list1中的每个元素取出来</span>            <span class="comment"># index是元素下表，i是list1中的元素</span>            list1[index] = i + n        list1.sort()        n += <span class="number">101</span>    <span class="comment"># 调用一下内部函数才会执行</span>    inner_func()    <span class="built_in">print</span>(list1)    <span class="built_in">print</span>(n)<span class="comment"># 调用func</span>func()</code></pre><pre><code class="highlight python">a = <span class="number">100</span>  <span class="comment"># 全局变量</span><span class="keyword">def</span> <span class="title function_">func</span>():    <span class="comment"># 声明变量</span>    b = <span class="number">99</span>    <span class="comment"># 声明函数</span>    <span class="keyword">def</span> <span class="title function_">inner_func</span>():        <span class="keyword">nonlocal</span> b  <span class="comment"># 修改局部变量</span>        <span class="keyword">global</span> a  <span class="comment"># 修改全局变量</span>        c = <span class="number">88</span>        <span class="comment"># 尝试修改</span>        c += <span class="number">12</span>        b += <span class="number">1</span>        <span class="comment"># 尝试打印</span>        a += <span class="number">10</span>        <span class="built_in">print</span>(a, b, c)    <span class="comment"># 调用内部函数</span>    inner_func()    <span class="comment"># 使用locals()内置函数进行查看，可以看到当前函数中声明的内容有哪些</span>    <span class="comment"># locals()是一个字典，key:value</span>    <span class="built_in">print</span>(<span class="built_in">locals</span>())    <span class="built_in">print</span>(<span class="built_in">globals</span>())<span class="comment"># 调用函数</span>func()</code></pre><pre><code class="highlight python"><span class="comment"># 闭包</span><span class="comment"># 函数中 提出的概念，</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">条件：</span><span class="string">1.外部函数中定义了内部函数</span><span class="string">2.外部函数是有返回值</span><span class="string">3.返回值的是：内部函数</span><span class="string">4.内部函数引用了外部函数的变量</span><span class="string">格式：</span><span class="string">def 外部函数():</span><span class="string">    ...</span><span class="string">    def 内部函数():</span><span class="string">        ...</span><span class="string">    return 内部函数</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">func</span>():    a = <span class="number">100</span>    <span class="keyword">def</span> <span class="title function_">inner_func</span>():        b = <span class="number">99</span>        <span class="built_in">print</span>(a, b)    <span class="built_in">print</span>(<span class="built_in">locals</span>())    <span class="keyword">return</span> inner_func  <span class="comment"># 不能加括号，如果加括号表示调用，不加括号才是扔出去</span>x = func()<span class="built_in">print</span>(x)<span class="comment"># x就是内部函数，x()就表示调用函数</span>x()</code></pre><pre><code class="highlight python"><span class="comment"># 闭包</span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):    c = <span class="number">10</span>    <span class="keyword">def</span> <span class="title function_">inner_func</span>():        s = a + b + c        <span class="built_in">print</span>(<span class="string">&#x27;相加之后的结果是：&#x27;</span>, s)    <span class="keyword">return</span> inner_func<span class="comment"># 调用func</span>ifunc = func(<span class="number">6</span>, <span class="number">9</span>)  <span class="comment"># ifunc就是inner_func ifunc = inner_func</span>ifunc()  <span class="comment"># 当你调用func（6，9）----&gt;a=6,b=9----&gt;inner_func()内部函数----&gt;返回内部函数</span><span class="comment"># （此时返回的内部函数已经记录此时的a和b的值，所以不会收到a，b改变影响</span>ifunc1 = func(<span class="number">2</span>, <span class="number">8</span>)ifunc1()</code></pre><pre><code class="highlight python"><span class="comment"># 计数器</span><span class="keyword">def</span> <span class="title function_">generate_count</span>():    container = [<span class="number">0</span>]    <span class="keyword">def</span> <span class="title function_">add_one</span>():        container[<span class="number">0</span>] = container[<span class="number">0</span>] + <span class="number">1</span>  <span class="comment"># [1]</span>        <span class="built_in">print</span>(<span class="string">&#x27;当前是第&#123;&#125;次访问&#x27;</span>.<span class="built_in">format</span>(container[<span class="number">0</span>]))    <span class="keyword">return</span> add_one<span class="comment"># 内部函数就是一个计数器</span>counter = generate_count()counter()  <span class="comment"># 第一次访问</span>counter()  <span class="comment"># 第二次访问</span>counter()  <span class="comment"># 第三次访问</span></code></pre><pre><code class="highlight python"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">闭包有什么缺点呢？</span><span class="string">闭包的缺点1，作用域没有你们直观</span><span class="string">闭包的缺点2，因为变量是不会被垃圾回收所以有一定的内存占用问题。</span><span class="string"></span><span class="string">闭包作用：1.可以使用同级的作用域</span><span class="string">闭包作用：2.读取其它元素的内部变量</span><span class="string">闭包作用：3.延长作用域</span><span class="string"></span><span class="string">闭包总结</span><span class="string">1.闭包似优化了变量，原来需要类对象完成的工作，闭包也可以完成</span><span class="string">2.由于闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存，</span><span class="string">3.闭包的好处，使代码变的简洁，便于阅读代码</span><span class="string">4.闭包是理解装饰器的基础</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">func</span>():    a = <span class="number">100</span>    <span class="keyword">def</span> <span class="title function_">inner_func1</span>():        b = <span class="number">90</span>        s = a + b        <span class="built_in">print</span>(s)    <span class="keyword">def</span> <span class="title function_">inner_func2</span>():  <span class="comment"># define</span>        inner_func1()  <span class="comment"># 调用inner_func1</span>        <span class="built_in">print</span>(<span class="string">&#x27;------&gt;inner_func2&#x27;</span>, a)  <span class="comment"># 同级可以访问</span>        <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>    <span class="keyword">return</span> inner_func2  <span class="comment"># 加括号表示调用，而不是扔出去</span><span class="comment"># 调用func</span>f = func()  <span class="comment"># 接收return inner_func2</span><span class="comment"># print(f)            # 输出内存地址才正确&lt;function func.&lt;locals&gt;.inner_func2 at 0x0000026BEBBEED30&gt;</span>f()  <span class="comment"># 显示return inner_func2</span>ff = f()  <span class="comment"># 使用ff接收return ’hello‘，就可以输出hello</span><span class="built_in">print</span>(ff)</code></pre><pre><code class="highlight python"><span class="comment"># 装饰器</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">加入购物车，付款，修改收货地址。。。。。</span><span class="string">判断用户的登录状态，</span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">number</span>):    a = <span class="number">100</span>    <span class="keyword">def</span> <span class="title function_">inner_func</span>():        <span class="keyword">nonlocal</span> a, number        number += <span class="number">1</span>        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(number):            a += <span class="number">1</span>        <span class="built_in">print</span>(<span class="string">&#x27;修改后的a：&#x27;</span>, a)    <span class="keyword">return</span> inner_func<span class="comment"># 调用func</span>f = func(<span class="number">5</span>)f()<span class="comment"># 装饰器函数作为参数</span>a = <span class="number">50</span>f1 = func(a)  <span class="comment"># a是实参</span>f1()</code></pre><pre><code class="highlight python"><span class="comment"># # 地址的引用</span><span class="comment"># a = 10  # 声明整形的变量</span><span class="comment"># b = a</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def test():  # 声明函数</span><span class="comment">#     print(&#x27;---------------test-------------&#x27;)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># t = test  # 将test()函数内存地址赋值给t</span><span class="comment"># t()</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># def func(f):</span><span class="comment">#     print(f)  # &lt;function test at 0x000001AB91B0E040&gt;</span><span class="comment">#     f()  # -----------test-------</span><span class="comment">#     print(&#x27;-----------func----------&#x27;)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># # 调用</span><span class="comment"># func(test)</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">特点：</span><span class="string">1.函数A是作为参数出现的（函数B就接收函数A作为参数）</span><span class="string">2.要有闭包的特点</span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># 定义一个装饰器</span><span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):    a = <span class="number">100</span>    <span class="built_in">print</span>(<span class="string">&#x27;wrapper外层打印测试&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">wrapper</span>():        func()        <span class="built_in">print</span>(<span class="string">&#x27;----------&gt;刷漆&#x27;</span>)        <span class="built_in">print</span>(<span class="string">&#x27;----------&gt;装门&#x27;</span>)        <span class="built_in">print</span>(<span class="string">&#x27;----------&gt;铺地板&#x27;</span>, a)    <span class="built_in">print</span>(<span class="string">&#x27;wrapper加载结束&#x27;</span>)    <span class="keyword">return</span> wrapper<span class="comment"># 使用装饰器</span><span class="meta">@decorate  </span><span class="comment"># 需要在decorate这个函数传入函数</span><span class="keyword">def</span> <span class="title function_">house</span>():    <span class="built_in">print</span>(<span class="string">&#x27;我是毛胚房。。。。&#x27;</span>)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">1.house被装饰函数，</span><span class="string">2.将被装饰函数作为参数传给装饰器decorate</span><span class="string">3.执行decorate函数</span><span class="string">4.将返回值又赋值给house</span><span class="string">&#x27;&#x27;&#x27;</span><span class="built_in">print</span>(house)house()<span class="comment"># def house1():</span><span class="comment">#     print(&#x27;刷油漆&#x27;)</span><span class="comment">#     print(&#x27;铺地板&#x27;)</span><span class="comment">#</span><span class="comment">#</span><span class="comment"># 调用house</span><span class="comment"># house()</span></code></pre><pre><code class="highlight python"><span class="comment"># 登录校验</span><span class="keyword">import</span> time<span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 万能装饰器</span>        <span class="built_in">print</span>(<span class="string">&#x27;正在校验中.....&#x27;</span>)        time.sleep(<span class="number">2</span>)  <span class="comment"># 休眠里面</span>        <span class="built_in">print</span>(<span class="string">&#x27;校验完毕.....&#x27;</span>)        <span class="comment"># 调用原函数</span>        func(*args, **kwargs)    <span class="keyword">return</span> wrapper<span class="meta">@decorate</span><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">n</span>):    <span class="built_in">print</span>(<span class="string">&#x27;------f1-----&#x27;</span>, n)f1(<span class="number">1</span>)  <span class="comment"># 此时f1是wrapper</span><span class="meta">@decorate</span><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">name, age</span>):    <span class="built_in">print</span>(<span class="string">&#x27;------f2-----&#x27;</span>, name, age)f2(<span class="string">&#x27;丽丽&#x27;</span>, <span class="number">20</span>)<span class="meta">@decorate</span><span class="keyword">def</span> <span class="title function_">f3</span>(<span class="params">studens, clazz=<span class="string">&#x27;1905&#x27;</span></span>):    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;班级的学生如下：&#x27;</span>.<span class="built_in">format</span>(clazz))    <span class="keyword">for</span> stu <span class="keyword">in</span> studens:        <span class="built_in">print</span>(stu)studens = [<span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;gg&#x27;</span>, <span class="string">&#x27;bao&#x27;</span>]f3(studens, clazz=<span class="string">&#x27;1904&#x27;</span>)<span class="meta">@decorate</span><span class="keyword">def</span> <span class="title function_">f4</span>():    <span class="built_in">print</span>(<span class="string">&#x27;---------f4&#x27;</span>)f4()<span class="string">&#x27;&#x27;&#x27;</span><span class="string">print</span><span class="string">正在校验中.....</span><span class="string">校验完毕.....</span><span class="string">------f1----- 1</span><span class="string">正在校验中.....</span><span class="string">校验完毕.....</span><span class="string">------f2----- 丽丽 20</span><span class="string">正在校验中.....</span><span class="string">校验完毕.....</span><span class="string">1904班级的学生如下：</span><span class="string">lili</span><span class="string">gg</span><span class="string">bao</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight python"><span class="comment"># 装饰器</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">如果装饰器是多层的，谁距离函数u最近就优先使用那个装饰器</span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">zhuang1</span>(<span class="params">func</span>):    <span class="built_in">print</span>(<span class="string">&#x27;------1 start&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):        func()        <span class="built_in">print</span>(<span class="string">&#x27;刷漆&#x27;</span>)    <span class="built_in">print</span>(<span class="string">&#x27;------1 end&#x27;</span>)    <span class="keyword">return</span> wrapper<span class="keyword">def</span> <span class="title function_">zhuang2</span>(<span class="params">func</span>):    <span class="built_in">print</span>(<span class="string">&#x27;------2 start&#x27;</span>)    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):        func()        <span class="built_in">print</span>(<span class="string">&#x27;扣地板&#x27;</span>)    <span class="built_in">print</span>(<span class="string">&#x27;------2 end&#x27;</span>)    <span class="keyword">return</span> wrapper<span class="meta">@zhuang2</span><span class="meta">@zhuang1  </span><span class="comment"># 谁近先装谁</span><span class="keyword">def</span> <span class="title function_">house</span>():    <span class="built_in">print</span>(<span class="string">&#x27;我是毛胚房.....&#x27;</span>)house()<span class="string">&#x27;&#x27;&#x27;</span><span class="string">------1 start</span><span class="string">------1 end</span><span class="string">------2 start</span><span class="string">------2 end</span><span class="string">我是毛胚房.....</span><span class="string">刷漆</span><span class="string">扣地板</span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight python"><span class="comment"># 装饰器带参数，需要三层函数</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">带参数的装饰器是三层的</span><span class="string">最外层的函数负责接收装饰器参数</span><span class="string">里面的内容函数原装饰器的内容</span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">a</span>):  <span class="comment"># 第一层</span>    <span class="keyword">def</span> <span class="title function_">decorate</span>(<span class="params">func</span>):  <span class="comment"># 第二层</span>        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):  <span class="comment"># 第三层</span>            func(*args, **kwargs)            <span class="built_in">print</span>(<span class="string">&#x27;------&gt;铺地砖&#123;&#125;块&#x27;</span>.<span class="built_in">format</span>(a))        <span class="keyword">return</span> wrapper  <span class="comment"># 返出来的是第三层</span>    <span class="keyword">return</span> decorate  <span class="comment"># 返出来的是第二层</span><span class="meta">@outer(<span class="params"><span class="number">10</span></span>)</span><span class="keyword">def</span> <span class="title function_">house</span>(<span class="params">time</span>):    <span class="built_in">print</span>(<span class="string">&#x27;我&#123;&#125;日期拿到房子的钥匙，毛坯房。。。&#x27;</span>.<span class="built_in">format</span>(time))<span class="meta">@outer(<span class="params"><span class="number">100</span></span>)</span><span class="keyword">def</span> <span class="title function_">street</span>():    <span class="built_in">print</span>(<span class="string">&#x27;新修街道的名字是：黑泉路&#x27;</span>)house(<span class="string">&#x27;2019-6-12&#x27;</span>)street()</code></pre><pre><code class="highlight python"><span class="comment"># 开发：登录验证</span><span class="keyword">import</span> timeisLogin = <span class="literal">False</span>  <span class="comment"># 默认没有登录</span><span class="keyword">def</span> <span class="title function_">login</span>():    username = <span class="built_in">input</span>(<span class="string">&#x27;输入用户名：&#x27;</span>)    password = <span class="built_in">input</span>(<span class="string">&#x27;输入密码：&#x27;</span>)    <span class="keyword">if</span> username == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;admin&#x27;</span>:        <span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)        <span class="keyword">return</span> <span class="literal">True</span>    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;登录失败，用户名或密码错误&#x27;</span>)        login()        <span class="keyword">return</span> <span class="literal">False</span><span class="comment"># 定义一个装饰器，进行付款验证</span><span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">func</span>):    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):        <span class="keyword">global</span> isLogin        <span class="built_in">print</span>(<span class="string">&#x27;-----正在进行付款-----&#x27;</span>)        <span class="comment"># 验证用户是否登录</span>        <span class="keyword">if</span> isLogin:            func(*args, **kwargs)        <span class="keyword">else</span>:            <span class="comment"># 跳转到登录页面</span>            time.sleep(<span class="number">2</span>)            <span class="built_in">print</span>(<span class="string">&#x27;用户没有登录,请登录之后再付款&#x27;</span>)            isLogin = login()    <span class="keyword">return</span> wrapper<span class="meta">@login_required</span><span class="keyword">def</span> <span class="title function_">pay</span>(<span class="params">money</span>):    <span class="built_in">print</span>(<span class="string">&#x27;正在付款,付款金额是：&#123;&#125;元&#x27;</span>.<span class="built_in">format</span>(money))    <span class="built_in">print</span>(<span class="string">&#x27;付款中...&#x27;</span>)    time.sleep(<span class="number">2</span>)    <span class="built_in">print</span>(<span class="string">&#x27;付款完成&#x27;</span>)pay(<span class="number">10000</span>)pay(<span class="number">10000</span>)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">-----正在进行付款-----</span><span class="string">用户没有登录,请登录之后再付款</span><span class="string">输入用户名：admin</span><span class="string">输入密码：admin</span><span class="string">result True</span><span class="string">-----正在进行付款-----</span><span class="string">正在付款,付款金额是：10000元</span><span class="string">付款中...</span><span class="string">付款完成</span><span class="string">&#x27;&#x27;&#x27;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python可变参数列表拆装</title>
      <link href="/posts/10926.html"/>
      <url>/posts/10926.html</url>
      
        <content type="html"><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, *args</span>):    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, args))func(<span class="number">2</span>, [<span class="number">1</span>, <span class="number">23</span>, <span class="number">4</span>], <span class="string">&#x27;fad&#x27;</span>)<span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a, b=<span class="number">10</span>, c=<span class="number">3</span>, **kwargs</span>):    <span class="built_in">print</span>(a, b, c, kwargs)func2(<span class="number">1</span>)  <span class="comment"># 1 10 3 &#123;&#125;  给默认值所以可传入一个参数</span>func2(<span class="number">2</span>, b=<span class="number">11</span>)  <span class="comment"># 2 11 3 &#123;&#125;</span>func2(<span class="number">3</span>, c=<span class="number">5</span>, b=<span class="number">7</span>, x=<span class="number">1</span>, y=<span class="number">2</span>)  <span class="comment"># 3 7 5 &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2&#125;，传值的时候可以打乱位置</span><span class="keyword">def</span> <span class="title function_">func3</span>(<span class="params">a, *args, **kwargs</span>):    <span class="built_in">print</span>(a, args, kwargs)t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)func3(<span class="number">1</span>, t)  <span class="comment"># 1 ((1, 2, 3, 4),) &#123;&#125;</span>l = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>]func3(<span class="number">1</span>, l, c=<span class="number">9</span>, b=<span class="number">6</span>)  <span class="comment"># 1 ([2, 5, 8],) &#123;&#x27;c&#x27;: 9, &#x27;b&#x27;: 6&#125;</span>dict1 = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;3&#x27;</span>: <span class="string">&#x27;c&#x27;</span>&#125;func3(<span class="number">1</span>, *l, **dict1)       <span class="comment"># 1 (2, 5, 8) &#123;&#x27;1&#x27;: &#x27;a&#x27;, &#x27;2&#x27;: &#x27;b&#x27;, &#x27;3&#x27;: &#x27;c&#x27;&#125;        # *拆列表 **拆字典</span><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">name, *args</span>):    <span class="keyword">if</span> <span class="built_in">len</span>(args) &gt; <span class="number">0</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> args:      <span class="comment"># 这里args是元组</span>            <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;学过了&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, i))    <span class="keyword">else</span>:        <span class="built_in">print</span>(<span class="string">&#x27;没有学过任何语言&#x27;</span>)courses = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;c++&#x27;</span>, <span class="string">&#x27;python&#x27;</span>]<span class="comment"># 调用函数</span>func1(<span class="string">&#x27;健健&#x27;</span>, *courses)       <span class="comment"># *拆列表（拆包）</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">无参数函数：</span><span class="string">    def func():</span><span class="string">        pass</span><span class="string">    func() ---调用</span><span class="string">    </span><span class="string">    有参数函数</span><span class="string">1.普通参数</span><span class="string">    def func(name,age):</span><span class="string">        pass</span><span class="string">    func(&#x27;aa&#x27;,19) ---&gt;形参与实参的个数要一致</span><span class="string"></span><span class="string">2.可变参数：</span><span class="string">    A.</span><span class="string">        def func(*args):</span><span class="string">            pass</span><span class="string">        func() ----&gt; 函数调用时，实参的个数可以没有，也可以多个，*不能是关键字参数</span><span class="string">        func(4) </span><span class="string">        func(5,&#x27;h&#x27;)</span><span class="string"></span><span class="string">    B.</span><span class="string">        def func(**kwargs):</span><span class="string">            pass</span><span class="string">        func(a=1,b=2)----&gt; 函数调用时，实参的个数可以没有，也可以多个，**必须是关键字参数</span><span class="string">    </span><span class="string">    C.</span><span class="string">        def func(*args,**kwargs):</span><span class="string">            pass</span><span class="string">        list1 = [1,2,3,4,5]</span><span class="string">        dict1 = &#123;&#x27;1&#x27;:&#x27;a&#x27;,&#x27;2&#x27;:&#x27;b&#x27;,&#x27;3&#x27;:&#x27;c&#x27;&#125;</span><span class="string">        func(*list1,**dict1)    拆包func(1,2,3,4,5,&#x27;1&#x27;:&#x27;a&#x27;,&#x27;2&#x27;:&#x27;b&#x27;,&#x27;3&#x27;:&#x27;c&#x27;)</span><span class="string">    </span><span class="string">    D.混用</span><span class="string">        def func(name,*args,*8kwargs):</span><span class="string">            pass</span><span class="string">        func(&#x27;tom&#x27;) ----&gt;必须赋值</span><span class="string">3.默认值</span><span class="string">    def func(name,age=18):</span><span class="string">        pass</span><span class="string">    func(&#x27;tom&#x27;) ----&gt; tom 18</span><span class="string">    func(&#x27;tom&#x27;,age = 20) ----&gt;关键字赋值</span><span class="string">        </span><span class="string">&#x27;&#x27;&#x27;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python集合</title>
      <link href="/posts/19623.html"/>
      <url>/posts/19623.html</url>
      
        <content type="html"><![CDATA[<pre><code class="highlight python">集合：    <span class="built_in">list</span> <span class="built_in">tuple</span>  ----&gt; <span class="built_in">set</span>()    无序不重复的序列，集合    无序-----&gt;跟下标相关    s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; ----&gt;s[<span class="number">1</span>]    <span class="keyword">for</span> i <span class="keyword">in</span> s:    <span class="built_in">print</span>(i)内置函数：添加：add update删除：remove discard pop clear运算相关函数- difference()| union&amp; intersection()^ symmetric_difference()可变和不可变可变：地址不变里面内容改变 <span class="built_in">list</span> <span class="built_in">dict</span> <span class="built_in">set</span>不可变：只要内容改变，必须改变地址 <span class="built_in">int</span> <span class="built_in">str</span> <span class="built_in">float</span> <span class="built_in">tuple</span> <span class="built_in">frozenset</span>类型转换：<span class="built_in">str</span> ----&gt; <span class="built_in">list</span> <span class="built_in">set</span> ... 相互转换<span class="built_in">list</span> ---&gt; <span class="built_in">set</span> <span class="built_in">tuple</span> <span class="built_in">dict</span> 相互的转换函数：    增加代码的复用，减少代码的冗余    <span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">[参数,]</span>):        函数体没有参数:<span class="keyword">def</span> <span class="title function_">add</span>():    add()有参数：<span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):    result = a+b    <span class="built_in">print</span>(result)调用：add(<span class="number">1</span>,<span class="number">3</span>)add(<span class="number">2</span>,<span class="number">8</span>)</code></pre><pre><code class="highlight python"><span class="comment"># 不重复特点：</span>list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>]<span class="comment"># 声明集合：set</span>s1 = <span class="built_in">set</span>()s2 = &#123;&#125;  <span class="comment"># 字典：&#123;key:value&#125;    集合&#123;元素1, 元素2, 元素3&#125;</span><span class="built_in">print</span>()<span class="comment"># 应用：</span>s3 = <span class="built_in">set</span>(list1)<span class="built_in">print</span>(s3)<span class="comment"># 增删改查</span><span class="comment"># 1.增加      s1 = set()</span><span class="comment"># add()     添加一个元素</span><span class="comment"># update    可以添加多个元素</span>s1.add(<span class="string">&#x27;hello&#x27;</span>)s1.add(<span class="string">&#x27;小猪佩奇&#x27;</span>)<span class="built_in">print</span>(s1)t1 = (<span class="string">&#x27;林志玲&#x27;</span>, <span class="string">&#x27;言承旭&#x27;</span>)s1.update(t1)<span class="built_in">print</span>(s1)<span class="comment"># 2.删除 remove 如果存在删除不存在报错KeyError pop clear</span>s1.remove(<span class="string">&#x27;言承旭&#x27;</span>)<span class="built_in">print</span>(s1)<span class="comment"># s1.remove(&#x27;道明寺&#x27;)    # KeyError: &#x27;道明寺&#x27;</span><span class="comment"># print(s1)</span>s1.pop()<span class="built_in">print</span>(s1)s1.clear()<span class="built_in">print</span>(s1)<span class="comment"># dicard() 类似remove 在移除不存在的值不会报错</span></code></pre><pre><code class="highlight python"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">    1.产生10个1-20的随机数去除里面的重复项</span><span class="string">    2.键盘输入一个元素，将此元素从不重复的集合中删除</span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">import</span> random<span class="comment"># 方法1</span><span class="comment"># list1 = []</span><span class="comment"># # set1 = set()</span><span class="comment"># for i in range(10):</span><span class="comment">#     ran = random.randint(1, 20)</span><span class="comment">#     list1.append(ran)</span><span class="comment"># # set1.update(list1)</span><span class="comment"># set1 = set(list1)</span><span class="comment"># print(list1)</span><span class="comment"># print(set1)</span><span class="comment"># result = int(input(&#x27;请输入一个想要删除的数字：&#x27;))</span><span class="comment"># set1.discard(result)</span><span class="comment"># print(set1)</span><span class="comment"># 方法2</span>set1 = <span class="built_in">set</span>()<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):    ran = random.randint(<span class="number">1</span>, <span class="number">20</span>)    set1.add(ran)<span class="built_in">print</span>(set1)<span class="comment"># 其他：符号操作</span><span class="built_in">print</span>(<span class="number">6</span> <span class="keyword">in</span> set1)set2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;set3 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;<span class="built_in">print</span>(set2 == set3)  <span class="comment"># 判断两个集合中的内容是否相等</span><span class="comment"># 测试：print(set2 != set3)</span><span class="comment"># (+ * 不支持) - &amp; |</span><span class="comment"># set4 = set2+set3  报错s</span><span class="comment"># print(set4)</span>set4 = set3 - set2  <span class="comment"># 差集 difference</span>set5 = set3.difference(set2)<span class="built_in">print</span>(set4, set5)<span class="comment"># &amp;交集 intersection()</span>set6 = set3 &amp; set2<span class="built_in">print</span>(set6)set7 = set3.intersection(set2)<span class="built_in">print</span>(set7)<span class="comment"># | 交集 union() 联合</span>set9 = set3 | set2<span class="built_in">print</span>(set9)<span class="built_in">print</span>(set9)</code></pre><pre><code class="highlight python"><span class="string">&#x27;&#x27;&#x27;</span><span class="string">已知两个列表：</span><span class="string">l1 = [5, 1, 2, 9, 0, 3]</span><span class="string">l2 = [7, 2, 5, 7, 9]</span><span class="string">找出两个列表的不同元素</span><span class="string">找出两个列表的相同元素</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span>l1 = [<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>]l2 = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]l1 = <span class="built_in">set</span>(l1)l2 = <span class="built_in">set</span>(l2)<span class="comment"># 对称差集</span>result = (l1 | l2) - (l1 &amp; l2)<span class="built_in">print</span>(result)result = l1 ^ l2  <span class="comment"># 列表中不一样的元素，对称差集， symmetric_difference()</span><span class="built_in">print</span>(result)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">difference_update()</span><span class="string">l1.difference(l2)</span><span class="string">l1.difference_update(l2) update不需要赋值</span><span class="string">l1.intersection_update(l2)  交集并赋值</span><span class="string">symmetric_difference_update()   对称差集并赋值</span><span class="string">update不需要赋值</span><span class="string">&#x27;&#x27;&#x27;</span><span class="built_in">print</span>(l1.difference_update(l2))<span class="built_in">print</span>(l1.intersection_update(l2))<span class="string">&#x27;&#x27;&#x27;</span><span class="string">关键字：set</span><span class="string">作用：去重</span><span class="string">符号：- | &amp; ^</span><span class="string"></span><span class="string">内置函数：</span><span class="string">    增加：add()    update()</span><span class="string">    删除：remove() discard()   pop()   clear()</span><span class="string">    运算：difference() intersection()  union() symmetric_difference()</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span></code></pre><pre><code class="highlight python"><span class="comment"># 可变 和不可变</span><span class="comment"># 不可变：对象所指向的内存中的值是不可变的</span><span class="comment"># 不可变的类型：int    str     float   元组tuple</span>num = <span class="number">10</span>s1 = <span class="string">&#x27;abc&#x27;</span><span class="built_in">print</span>(<span class="built_in">id</span>(s1))s1 = <span class="string">&#x27;abcd&#x27;</span><span class="built_in">print</span>(<span class="built_in">id</span>(s1))t1 = (<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>)<span class="built_in">print</span>(<span class="built_in">id</span>(t1))t1 = (<span class="number">3</span>, <span class="number">5</span>)<span class="built_in">print</span>(<span class="built_in">id</span>(t1))<span class="comment"># 可变的元素：该对象所指向的内存中的值是可以改变的</span><span class="comment"># 可变类型： dict    list    set</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内置函数+匿名函数</title>
      <link href="/posts/4090.html"/>
      <url>/posts/4090.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/4090/image-20211004000841483.webp" alt="image-20211004000841483"></p><p><img src="/posts/4090/image-20211004011556646.webp" alt="image-20211004011556646"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/posts/16177.html"/>
      <url>/posts/16177.html</url>
      
        <content type="html"><![CDATA[<p><img src="/posts/16177/image-20211004110415017.webp" alt="image-20211004110415017"></p><pre><code class="highlight python"><span class="comment"># file1</span><span class="comment"># 文件操作：</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">文件上传：</span><span class="string">保存log</span><span class="string"></span><span class="string">系统函数</span><span class="string">open(file,mode,buffering,encodeing)</span><span class="string"></span><span class="string">读：</span><span class="string">    open(path/filename,&#x27;rt&#x27;) -----&gt;返回值：stream(管道)</span><span class="string">    container = stream.read() ----&gt;读取管道中内容</span><span class="string">    注意：如果传递的path/filename有误，则会报错：FileNotFoundError</span><span class="string">    如果是图片则不能使用默认的读取方式，mode = &#x27;rb&#x27;</span><span class="string"></span><span class="string">    总结：</span><span class="string">    read()</span><span class="string">    readline()  每次读取一行内容</span><span class="string">    readlines() 读取所有的行保存到列表中</span><span class="string">    readable()  判断是否是可读的</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span>stream = <span class="built_in">open</span>(<span class="string">r&#x27;../../个人工具/base.txt&#x27;</span>, <span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)  <span class="comment"># rt文本文档读</span><span class="comment"># container = stream.read()</span><span class="comment"># print(container)</span>result = stream.readable()  <span class="comment"># able判断是否可以读取</span><span class="built_in">print</span>(result)<span class="comment"># while True:</span><span class="comment">#     line = stream.readline()</span><span class="comment">#     print(line)</span><span class="comment">#     if not line:</span><span class="comment">#         break</span>lines = stream.readlines()  <span class="comment"># 保存到列表中</span><span class="built_in">print</span>(lines)<span class="keyword">for</span> i <span class="keyword">in</span> lines:    <span class="built_in">print</span>(i)stream = <span class="built_in">open</span>(<span class="string">r&#x27;../../img/2021-09-26/OHR.MackenzieRiver_ZH-CN0214805768_480x800.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)container = stream.read()<span class="built_in">print</span>(container)<span class="comment"># file2</span><span class="comment"># 写文件</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">stream = open(r&#x27;aa.txt&#x27;, &#x27;w&#x27;)</span><span class="string">mode 是&#x27;w&#x27;表示写操作</span><span class="string">方法：</span><span class="string">    write(内容)   每次都会将原来的内容清空，然后写当前的内容</span><span class="string">    writelines(Iterable)    没有换行的效果 4444444GGGGRE</span><span class="string">    straem.writelines([&#x27;赌神：小明明\n&#x27;, &#x27;赌侠笑道\n&#x27;, &#x27;赌圣周星星\n&#x27;])</span><span class="string"></span><span class="string">如果有mode=&#x27;a&#x27; 表示追加</span><span class="string">&#x27;&#x27;&#x27;</span>straem = <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)s = <span class="string">&#x27;&#x27;&#x27;</span><span class="string">你好！</span><span class="string">    欢迎来到澳门菠菜，赠送给你一个金币！</span><span class="string">                赌王：小明</span><span class="string">&#x27;&#x27;&#x27;</span>result = straem.write(s)<span class="built_in">print</span>(result)straem.write(<span class="string">&#x27;      你需要戒指吗？？？\n&#x27;</span>)  <span class="comment"># 可以\n换行</span>straem.writelines([<span class="string">&#x27;        赌神：小明明\n&#x27;</span>, <span class="string">&#x27;        赌侠笑道\n&#x27;</span>, <span class="string">&#x27;      赌圣周星星\n&#x27;</span>])straem.write(<span class="string">&#x27;      僵尸先生&#x27;</span>)straem.close()  <span class="comment"># 释放资源</span><span class="comment"># 关闭之后就无法写入</span><span class="comment"># file3</span><span class="comment"># 文件的复制</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">原文件：../../img/2021-09-26/OHR.MackenzieRiver_ZH-CN0214805768_480x800.jpg</span><span class="string">目标文件：./1.jpg</span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;./OHR.MackenzieRiver_ZH-CN0214805768_1920x1080.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> result:    container = result.read()    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;1.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> wstream:        wstream.write(container)<span class="built_in">print</span>(<span class="string">&#x27;文件复制完成&#x27;</span>)<span class="comment"># os</span><span class="comment"># 模块：os.py</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">os.path:</span><span class="string">os.path.dirname(__file__)   获取当前文件所在的文件目录（绝对路径）</span><span class="string">os.path.join(path,&#x27;&#x27;)   返回的是一个拼接后的新的路径</span><span class="string"></span><span class="string">&#x27;&#x27;&#x27;</span><span class="keyword">import</span> os<span class="comment"># print(os.path)</span><span class="comment"># path = os.path.dirname(__file__)  # 显示当前目录的绝对路径</span><span class="comment"># print(path, &#x27;\n&#x27;, type(path))</span><span class="comment"># result = os.path.join(path, &#x27;a1.jpg&#x27;)</span><span class="comment"># print(result)</span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;./OHR.MackenzieRiver_ZH-CN0214805768_1920x1080.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> stream:  <span class="comment"># 要复制的文件</span>    container = stream.read()   <span class="comment"># 读取文件内容</span>    file = stream.name    filename = file[file.rfind(<span class="string">r&#x27;/&#x27;</span>)+<span class="number">1</span>:]    path = os.path.dirname(__file__)    path1 = os.path.join(path, filename)    <span class="keyword">with</span> <span class="built_in">open</span>(path1, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> wstream:        wstream.write(container)                <span class="comment"># file 01</span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;book/a1.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> wstrem:    wstrem.write(<span class="string">&#x27;hello&#x27;</span>)<span class="keyword">import</span> osresult = os.path.isabs(<span class="string">r&#x27;C:\\Users\\Wans\\AppData\\Local\\Programs\\Python39\\lib\\a1.txt&#x27;</span>)<span class="built_in">print</span>(<span class="string">&#x27;------&gt;&#x27;</span>, result)<span class="comment"># ------&gt; True</span>result1 = os.path.isabs(<span class="string">r&#x27;../day10_函数/func01.py&#x27;</span>)  <span class="comment"># 当前文件的上一级</span><span class="built_in">print</span>(<span class="string">&#x27;------&gt;&#x27;</span>, result1)<span class="comment"># ------&gt; False</span>result1 = os.path.isabs(<span class="string">r&#x27;/day10_函数/func01.py&#x27;</span>)  <span class="comment"># 找跟file01.py同级别的func01.py</span><span class="built_in">print</span>(<span class="string">&#x27;------&gt;&#x27;</span>, result1)<span class="comment"># ------&gt; True</span><span class="comment"># 获取路径，directory目录 文件夹</span><span class="comment"># 当前文件所在文件夹的路径</span>path = os.path.dirname(__file__)<span class="comment"># 通过相对路径得到绝对路径</span><span class="built_in">print</span>(path)<span class="comment"># D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\a.txt</span>path = os.path.abspath(<span class="string">&#x27;a.txt&#x27;</span>)<span class="built_in">print</span>(path)<span class="comment"># D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\a.txt</span><span class="comment"># 获取当前文件的绝对路径</span><span class="comment"># __file__ 当前文件</span>path = os.path.abspath(__file__)<span class="built_in">print</span>(path)<span class="comment"># D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\file01.py</span>path = os.getcwd()  <span class="comment"># 类似os.path.dirname(__file__)</span><span class="built_in">print</span>(path)<span class="comment"># D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件</span>r = os.path.isfile(os.getcwd())  <span class="comment"># isfile判断是不是文件</span><span class="built_in">print</span>(r)<span class="comment"># False</span>r = os.path.isdir(os.getcwd())  <span class="comment"># isdir判断是不是目录</span><span class="built_in">print</span>(r)<span class="comment"># True</span>path = <span class="string">r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\file01.py&#x27;</span>result = os.path.split(path)<span class="built_in">print</span>(result)  <span class="comment"># 输出前面是路径，后面是文件名</span><span class="comment"># (&#x27;D:\\Users\\Wans\\Desktop\\python stduy\\千峰笔记\\day13_文件&#x27;, &#x27;file01.py&#x27;)</span><span class="built_in">print</span>(result[<span class="number">1</span>])  <span class="comment"># 这样可以输出文件名</span><span class="comment"># filename = path[path.rfind(&#x27;\\&#x27;)+1:]</span><span class="comment"># file01.py</span>result = os.path.splitext(path)  <span class="comment"># 分割文件与扩展名查看文件的后缀</span><span class="built_in">print</span>(result)<span class="comment"># (&#x27;D:\\Users\\Wans\\Desktop\\python stduy\\千峰笔记\\day13_文件\\file01&#x27;, &#x27;.py&#x27;)</span><span class="built_in">print</span>(os.path.getsize(<span class="string">&#x27;a.txt&#x27;</span>))  <span class="comment"># 返回文件的大小，单位字节</span><span class="built_in">print</span>(os.path.join(os.getcwd(), <span class="string">&#x27;file&#x27;</span>, <span class="string">&#x27;a.txt&#x27;</span>))  <span class="comment"># 每多一个加一层</span><span class="comment"># D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\file\a.txt</span><span class="string">&#x27;&#x27;&#x27;</span><span class="string">os.path: 常用函数</span><span class="string">    dirname()</span><span class="string">    join()</span><span class="string">    split()</span><span class="string">    splittext()</span><span class="string">    getsize()</span><span class="string">    isabs()</span><span class="string">    isfile()</span><span class="string">    isdir()</span><span class="string">&#x27;&#x27;&#x27;</span><span class="comment"># file 02</span><span class="comment"># -*- codeing = utf-8 -*-</span><span class="comment"># @Time : 2021/10/26 19:08</span><span class="comment"># @Author : Wans</span><span class="comment"># @File : file02.py</span><span class="comment"># @Sofware : PyCharm</span><span class="comment"># os.path里面的函数</span><span class="comment"># os函数</span><span class="keyword">import</span> os<span class="comment"># os.getcwd()</span><span class="comment">#</span><span class="comment"># dir = os.getcwd()</span><span class="comment"># print(dir)</span><span class="comment"># # 返回指定目录下的所有的文件和文件夹</span><span class="comment"># print(os.listdir(r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记&#x27;))</span><span class="comment">#</span><span class="comment"># # 创建文件夹</span><span class="comment"># if not os.path.exists(r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\book&#x27;):</span><span class="comment">#     os.mkdir(r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\book&#x27;)</span><span class="comment"># os.rmdir(r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\book&#x27;)    #  只能删除空文件夹</span><span class="comment">#</span><span class="comment"># os.removedirs(r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\book&#x27;) # 目录不是空的</span><span class="comment"># os.remove(r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day13_文件\book\a1.txt&#x27;)</span><span class="comment"># 删除p4文件夹</span>path = <span class="string">r&#x27;/千峰笔记/day13_文件/book&#x27;</span><span class="comment"># filelist = os.listdir(path)</span><span class="comment"># for file in filelist:</span><span class="comment">#     path1 = os.path.join(path, file)</span><span class="comment">#     os.remove(path1)</span><span class="comment"># else:</span><span class="comment">#     os.removedirs(path)</span><span class="comment">#     # os.rmdir(path)</span><span class="comment"># print(&#x27;删除成功&#x27;)</span>path = os.getcwd()<span class="built_in">print</span>(path)<span class="comment"># 切换目录</span>f = os.chdir(<span class="string">r&#x27;D:\Users\Wans\Desktop\python stduy\千峰笔记\day12_函数&#x27;</span>)<span class="built_in">print</span>()path = os.getcwd()<span class="built_in">print</span>(path)<span class="string">&#x27;&#x27;&#x27;</span><span class="string">os模块下的方法：</span><span class="string">os.getcwd()     # 获取当前目录</span><span class="string">os.listdir()    # 浏览文件夹</span><span class="string">os.mkdir()      # 创建文件夹</span><span class="string">os.rmdir()      # 删除空的文件夹</span><span class="string">os.remove()     # 删除文件</span><span class="string">os.chdir()      # 切换目录</span><span class="string">&#x27;&#x27;&#x27;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python关键字参数和默认值参数</title>
      <link href="/posts/57307.html"/>
      <url>/posts/57307.html</url>
      
        <content type="html"><![CDATA[<h1 id="关键字参数和默认值参数"><a href="#关键字参数和默认值参数" class="headerlink" title="关键字参数和默认值参数"></a>关键字参数和默认值参数</h1><p>python **&lt;字典&gt;</p><p>可以将字典拆包</p><pre><code class="highlight python"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">**kwargs</span>):<span class="built_in">print</span>(kwargs)    <span class="comment"># 这里的**代表可以传递字典（以字典的形式传递参数）</span><span class="comment"># key：value只能以键值对方式传递</span><span class="comment"># 或者以**传值</span>func()func(a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>)<span class="comment"># 传递字典的方法</span>dict1 = &#123;<span class="string">&#x27;001&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;002&#x27;</span>: <span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;004&#x27;</span>: <span class="string">&#x27;c++&#x27;</span>&#125;func(**dict1)<span class="comment"># 拆包步骤：</span><span class="comment"># 1、func(001 = python,002 = java,004 = c++)将字典拆包成关键字参数的形式</span><span class="comment"># 2、func里面的参数都是关键字参数</span><span class="comment"># 3、将关键字参数再一次进行装包动作</span><span class="comment"># 4、装包成功：kwargs</span>studens = &#123;    <span class="string">&#x27;001&#x27;</span>: (<span class="string">&#x27;蔡徐坤&#x27;</span>, <span class="number">20</span>),    <span class="string">&#x27;002&#x27;</span>: (<span class="string">&#x27;王源&#x27;</span>, <span class="number">18</span>),    <span class="string">&#x27;003&#x27;</span>: (<span class="string">&#x27;王俊凯&#x27;</span>, <span class="number">21</span>),    <span class="string">&#x27;004&#x27;</span>: (<span class="string">&#x27;易烊千玺&#x27;</span>, <span class="number">19</span>)&#125;<span class="keyword">def</span> <span class="title function_">print_boy</span>(<span class="params">name, **persons</span>):    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;喜欢吃肉肉&#x27;</span>.<span class="built_in">format</span>(name))    <span class="keyword">if</span> <span class="built_in">isinstance</span>(persons, <span class="built_in">dict</span>):  <span class="comment"># 判断是不是什么类型：isinstance，这里判断是不是person是不是字典类型</span>        values = persons.values()  <span class="comment"># 如果是字典，那么使用values接受字典里面的键值对</span>        <span class="comment"># print(values)             # 输出字典</span>        <span class="keyword">for</span> name, age <span class="keyword">in</span> values:  <span class="comment"># 使用name和age接受values中的键值对</span>            <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;的年龄是&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, age))  <span class="comment"># 循环输出字典中的元素</span>print_boy(<span class="string">&#x27;健健&#x27;</span>, **studens)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
